"""Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT."""

from .basesdk import BaseSDK
import httpx
from moov import models, utils
from moov._hooks import HookContext
from moov.types import OptionalNullable, UNSET
from typing import Any, Dict, List, Mapping, Optional, Union


class Accounts(BaseSDK):
    def create_account(
        self,
        *,
        security: Union[
            models.CreateAccountSecurity, models.CreateAccountSecurityTypedDict
        ],
        account_type: models.AccountType,
        profile: Union[models.CreateProfile, models.CreateProfileTypedDict],
        x_moov_version: Optional[models.Versions] = None,
        x_wait_for: Optional[models.AccountWaitFor] = None,
        metadata: Optional[Dict[str, str]] = None,
        terms_of_service: Optional[
            Union[
                models.CreateAccountTermsOfService,
                models.CreateAccountTermsOfServiceTypedDict,
            ]
        ] = None,
        foreign_id: Optional[str] = None,
        customer_support: Optional[
            Union[models.CustomerSupport, models.CustomerSupportTypedDict]
        ] = None,
        settings: Optional[Union[models.Settings, models.SettingsTypedDict]] = None,
        capabilities: Optional[List[models.CapabilityID]] = None,
        retries: OptionalNullable[utils.RetryConfig] = UNSET,
        server_url: Optional[str] = None,
        timeout_ms: Optional[int] = None,
        http_headers: Optional[Mapping[str, str]] = None,
    ) -> models.Account:
        r"""You can create **business** or **individual** accounts for your users (i.e., customers, merchants) by passing the required
        information to Moov. Requirements differ per account type and requested [capabilities](https://docs.moov.io/guides/accounts/capabilities/requirements/).

        If you're requesting the `wallet`, `send-funds`, `collect-funds`, or `card-issuing` capabilities, you'll need to:
          + Send Moov the user [platform terms of service agreement](https://docs.moov.io/guides/accounts/requirements/platform-agreement/) acceptance.
            This can be done upon account creation, or by [patching](https://docs.moov.io/api/moov-accounts/accounts/patch/) the account using the `termsOfService` field.
        If you're creating a business account with the business type `llc`, `partnership`, or `privateCorporation`, you'll need to:
          + Provide [business representatives](https://docs.moov.io/api/moov-accounts/representatives/) after creating the account.
          + [Patch](https://docs.moov.io/api/moov-accounts/accounts/patch/) the account to indicate that business representative ownership information is complete.

        Visit our documentation to read more about [creating accounts](https://docs.moov.io/guides/accounts/create-accounts/) and [verification requirements](https://docs.moov.io/guides/accounts/requirements/identity-verification/).
        Note that the `mode` field (for production or sandbox) is only required when creating a _facilitator_ account. All non-facilitator account requests will ignore the mode field and be set to the calling facilitator's mode.

        :param security:
        :param account_type: The type of entity represented by this account.
        :param profile:
        :param x_moov_version: Specify an API version.
        :param x_wait_for: Optional header that indicates whether to wait for the connection to be created before returning from the account creation.
        :param metadata: Free-form key-value pair list. Useful for storing information that is not captured elsewhere.
        :param terms_of_service:
        :param foreign_id: Optional alias from a foreign/external system which can be used to reference this resource.
        :param customer_support: User-provided information that can be displayed on credit card transactions for customers to use when contacting a customer support team. This data is only allowed on a business account.
        :param settings: User provided settings to manage an account.
        :param capabilities:
        :param retries: Override the default retry configuration for this method
        :param server_url: Override the default server URL for this method
        :param timeout_ms: Override the default request timeout configuration for this method in milliseconds
        :param http_headers: Additional headers to set or replace on requests.
        """
        base_url = None
        url_variables = None
        if timeout_ms is None:
            timeout_ms = self.sdk_configuration.timeout_ms

        if server_url is not None:
            base_url = server_url

        request = models.CreateAccountRequest(
            x_moov_version=x_moov_version,
            x_wait_for=x_wait_for,
            create_account=models.CreateAccount(
                account_type=account_type,
                profile=utils.get_pydantic_model(profile, models.CreateProfile),
                metadata=metadata,
                terms_of_service=utils.get_pydantic_model(
                    terms_of_service, Optional[models.CreateAccountTermsOfService]
                ),
                foreign_id=foreign_id,
                customer_support=utils.get_pydantic_model(
                    customer_support, Optional[models.CustomerSupport]
                ),
                settings=utils.get_pydantic_model(settings, Optional[models.Settings]),
                capabilities=capabilities,
            ),
        )

        req = self._build_request(
            method="POST",
            path="/accounts",
            base_url=base_url,
            url_variables=url_variables,
            request=request,
            request_body_required=True,
            request_has_path_params=False,
            request_has_query_params=True,
            user_agent_header="user-agent",
            accept_header_value="application/json",
            http_headers=http_headers,
            security=utils.get_pydantic_model(security, models.CreateAccountSecurity),
            get_serialized_body=lambda: utils.serialize_request_body(
                request.create_account, False, False, "json", models.CreateAccount
            ),
            timeout_ms=timeout_ms,
        )

        if retries == UNSET:
            if self.sdk_configuration.retry_config is not UNSET:
                retries = self.sdk_configuration.retry_config

        retry_config = None
        if isinstance(retries, utils.RetryConfig):
            retry_config = (retries, ["429", "500", "502", "503", "504"])

        http_res = self.do_request(
            hook_ctx=HookContext(
                operation_id="createAccount", oauth2_scopes=[], security_source=security
            ),
            request=req,
            error_status_codes=[
                "400",
                "401",
                "403",
                "404",
                "409",
                "422",
                "429",
                "4XX",
                "500",
                "504",
                "5XX",
            ],
            retry_config=retry_config,
        )

        data: Any = None
        if utils.match_response(http_res, "200", "application/json"):
            return utils.unmarshal_json(http_res.text, models.Account)
        if utils.match_response(http_res, ["400", "409"], "application/json"):
            data = utils.unmarshal_json(http_res.text, models.GenericErrorData)
            raise models.GenericError(data=data)
        if utils.match_response(http_res, ["401", "403", "404", "429", "4XX"], "*"):
            http_res_text = utils.stream_to_text(http_res)
            raise models.APIError(
                "API error occurred", http_res.status_code, http_res_text, http_res
            )
        if utils.match_response(http_res, "422", "application/json"):
            data = utils.unmarshal_json(
                http_res.text, models.CreateAccountResponseBodyData
            )
            raise models.CreateAccountResponseBody(data=data)
        if utils.match_response(http_res, ["500", "504", "5XX"], "*"):
            http_res_text = utils.stream_to_text(http_res)
            raise models.APIError(
                "API error occurred", http_res.status_code, http_res_text, http_res
            )

        content_type = http_res.headers.get("Content-Type")
        http_res_text = utils.stream_to_text(http_res)
        raise models.APIError(
            f"Unexpected response received (code: {http_res.status_code}, type: {content_type})",
            http_res.status_code,
            http_res_text,
            http_res,
        )

    async def create_account_async(
        self,
        *,
        security: Union[
            models.CreateAccountSecurity, models.CreateAccountSecurityTypedDict
        ],
        account_type: models.AccountType,
        profile: Union[models.CreateProfile, models.CreateProfileTypedDict],
        x_moov_version: Optional[models.Versions] = None,
        x_wait_for: Optional[models.AccountWaitFor] = None,
        metadata: Optional[Dict[str, str]] = None,
        terms_of_service: Optional[
            Union[
                models.CreateAccountTermsOfService,
                models.CreateAccountTermsOfServiceTypedDict,
            ]
        ] = None,
        foreign_id: Optional[str] = None,
        customer_support: Optional[
            Union[models.CustomerSupport, models.CustomerSupportTypedDict]
        ] = None,
        settings: Optional[Union[models.Settings, models.SettingsTypedDict]] = None,
        capabilities: Optional[List[models.CapabilityID]] = None,
        retries: OptionalNullable[utils.RetryConfig] = UNSET,
        server_url: Optional[str] = None,
        timeout_ms: Optional[int] = None,
        http_headers: Optional[Mapping[str, str]] = None,
    ) -> models.Account:
        r"""You can create **business** or **individual** accounts for your users (i.e., customers, merchants) by passing the required
        information to Moov. Requirements differ per account type and requested [capabilities](https://docs.moov.io/guides/accounts/capabilities/requirements/).

        If you're requesting the `wallet`, `send-funds`, `collect-funds`, or `card-issuing` capabilities, you'll need to:
          + Send Moov the user [platform terms of service agreement](https://docs.moov.io/guides/accounts/requirements/platform-agreement/) acceptance.
            This can be done upon account creation, or by [patching](https://docs.moov.io/api/moov-accounts/accounts/patch/) the account using the `termsOfService` field.
        If you're creating a business account with the business type `llc`, `partnership`, or `privateCorporation`, you'll need to:
          + Provide [business representatives](https://docs.moov.io/api/moov-accounts/representatives/) after creating the account.
          + [Patch](https://docs.moov.io/api/moov-accounts/accounts/patch/) the account to indicate that business representative ownership information is complete.

        Visit our documentation to read more about [creating accounts](https://docs.moov.io/guides/accounts/create-accounts/) and [verification requirements](https://docs.moov.io/guides/accounts/requirements/identity-verification/).
        Note that the `mode` field (for production or sandbox) is only required when creating a _facilitator_ account. All non-facilitator account requests will ignore the mode field and be set to the calling facilitator's mode.

        :param security:
        :param account_type: The type of entity represented by this account.
        :param profile:
        :param x_moov_version: Specify an API version.
        :param x_wait_for: Optional header that indicates whether to wait for the connection to be created before returning from the account creation.
        :param metadata: Free-form key-value pair list. Useful for storing information that is not captured elsewhere.
        :param terms_of_service:
        :param foreign_id: Optional alias from a foreign/external system which can be used to reference this resource.
        :param customer_support: User-provided information that can be displayed on credit card transactions for customers to use when contacting a customer support team. This data is only allowed on a business account.
        :param settings: User provided settings to manage an account.
        :param capabilities:
        :param retries: Override the default retry configuration for this method
        :param server_url: Override the default server URL for this method
        :param timeout_ms: Override the default request timeout configuration for this method in milliseconds
        :param http_headers: Additional headers to set or replace on requests.
        """
        base_url = None
        url_variables = None
        if timeout_ms is None:
            timeout_ms = self.sdk_configuration.timeout_ms

        if server_url is not None:
            base_url = server_url

        request = models.CreateAccountRequest(
            x_moov_version=x_moov_version,
            x_wait_for=x_wait_for,
            create_account=models.CreateAccount(
                account_type=account_type,
                profile=utils.get_pydantic_model(profile, models.CreateProfile),
                metadata=metadata,
                terms_of_service=utils.get_pydantic_model(
                    terms_of_service, Optional[models.CreateAccountTermsOfService]
                ),
                foreign_id=foreign_id,
                customer_support=utils.get_pydantic_model(
                    customer_support, Optional[models.CustomerSupport]
                ),
                settings=utils.get_pydantic_model(settings, Optional[models.Settings]),
                capabilities=capabilities,
            ),
        )

        req = self._build_request_async(
            method="POST",
            path="/accounts",
            base_url=base_url,
            url_variables=url_variables,
            request=request,
            request_body_required=True,
            request_has_path_params=False,
            request_has_query_params=True,
            user_agent_header="user-agent",
            accept_header_value="application/json",
            http_headers=http_headers,
            security=utils.get_pydantic_model(security, models.CreateAccountSecurity),
            get_serialized_body=lambda: utils.serialize_request_body(
                request.create_account, False, False, "json", models.CreateAccount
            ),
            timeout_ms=timeout_ms,
        )

        if retries == UNSET:
            if self.sdk_configuration.retry_config is not UNSET:
                retries = self.sdk_configuration.retry_config

        retry_config = None
        if isinstance(retries, utils.RetryConfig):
            retry_config = (retries, ["429", "500", "502", "503", "504"])

        http_res = await self.do_request_async(
            hook_ctx=HookContext(
                operation_id="createAccount", oauth2_scopes=[], security_source=security
            ),
            request=req,
            error_status_codes=[
                "400",
                "401",
                "403",
                "404",
                "409",
                "422",
                "429",
                "4XX",
                "500",
                "504",
                "5XX",
            ],
            retry_config=retry_config,
        )

        data: Any = None
        if utils.match_response(http_res, "200", "application/json"):
            return utils.unmarshal_json(http_res.text, models.Account)
        if utils.match_response(http_res, ["400", "409"], "application/json"):
            data = utils.unmarshal_json(http_res.text, models.GenericErrorData)
            raise models.GenericError(data=data)
        if utils.match_response(http_res, ["401", "403", "404", "429", "4XX"], "*"):
            http_res_text = await utils.stream_to_text_async(http_res)
            raise models.APIError(
                "API error occurred", http_res.status_code, http_res_text, http_res
            )
        if utils.match_response(http_res, "422", "application/json"):
            data = utils.unmarshal_json(
                http_res.text, models.CreateAccountResponseBodyData
            )
            raise models.CreateAccountResponseBody(data=data)
        if utils.match_response(http_res, ["500", "504", "5XX"], "*"):
            http_res_text = await utils.stream_to_text_async(http_res)
            raise models.APIError(
                "API error occurred", http_res.status_code, http_res_text, http_res
            )

        content_type = http_res.headers.get("Content-Type")
        http_res_text = await utils.stream_to_text_async(http_res)
        raise models.APIError(
            f"Unexpected response received (code: {http_res.status_code}, type: {content_type})",
            http_res.status_code,
            http_res_text,
            http_res,
        )

    def list_accounts(
        self,
        *,
        security: Union[
            models.ListAccountsSecurity, models.ListAccountsSecurityTypedDict
        ],
        x_moov_version: Optional[models.Versions] = None,
        name: Optional[str] = None,
        email: Optional[str] = None,
        type_: Optional[models.AccountType] = None,
        foreign_id: Optional[str] = None,
        include_disconnected: Optional[bool] = None,
        capability: Optional[models.CapabilityID] = None,
        capability_status: Optional[models.CapabilityStatus] = None,
        skip: Optional[int] = None,
        count: Optional[int] = None,
        retries: OptionalNullable[utils.RetryConfig] = UNSET,
        server_url: Optional[str] = None,
        timeout_ms: Optional[int] = None,
        http_headers: Optional[Mapping[str, str]] = None,
    ) -> List[models.Account]:
        r"""List or search accounts to which the caller is connected.

        All supported query parameters are optional. If none are provided the response will include all connected accounts.
        Pagination is supported via the `skip` and `count` query parameters.
        Searching by name and email will overlap and return results based on relevance.

        :param security:
        :param x_moov_version: Specify an API version.
        :param name: Filter connected accounts by name.  If provided, this query will attempt to find matches against the following Account and Profile fields: <ul>   <li>Account `displayName`</li>   <li>Individual Profile `firstName`, `middleName`, and `lastName`</li>   <li>Business Profile `legalBusinessName`</li> </ul>
        :param email: Filter connected accounts by email address.    Provide the full email address to filter by email.
        :param type: Filter connected accounts by AccountType.    If the `type` parameter is used in combination with `name`, only the corresponding type's name fields will   be searched. For example, if `type=business` and `name=moov`, the search will attempt to find matches against   the display name and Business Profile name fields (`legalBusinessName`, and `doingBusinessAs`).
        :param foreign_id: Serves as an optional alias from a foreign/external system which can be used to reference this resource.
        :param include_disconnected: Filter disconnected accounts.  If true, the response will include disconnected accounts.
        :param capability: Filter connected accounts by the capability.
        :param capability_status: Filter connected accounts by the capability.
        :param skip:
        :param count:
        :param retries: Override the default retry configuration for this method
        :param server_url: Override the default server URL for this method
        :param timeout_ms: Override the default request timeout configuration for this method in milliseconds
        :param http_headers: Additional headers to set or replace on requests.
        """
        base_url = None
        url_variables = None
        if timeout_ms is None:
            timeout_ms = self.sdk_configuration.timeout_ms

        if server_url is not None:
            base_url = server_url

        request = models.ListAccountsRequest(
            x_moov_version=x_moov_version,
            name=name,
            email=email,
            type=type_,
            foreign_id=foreign_id,
            include_disconnected=include_disconnected,
            capability=capability,
            capability_status=capability_status,
            skip=skip,
            count=count,
        )

        req = self._build_request(
            method="GET",
            path="/accounts",
            base_url=base_url,
            url_variables=url_variables,
            request=request,
            request_body_required=False,
            request_has_path_params=False,
            request_has_query_params=True,
            user_agent_header="user-agent",
            accept_header_value="application/json",
            http_headers=http_headers,
            security=utils.get_pydantic_model(security, models.ListAccountsSecurity),
            timeout_ms=timeout_ms,
        )

        if retries == UNSET:
            if self.sdk_configuration.retry_config is not UNSET:
                retries = self.sdk_configuration.retry_config

        retry_config = None
        if isinstance(retries, utils.RetryConfig):
            retry_config = (retries, ["429", "500", "502", "503", "504"])

        http_res = self.do_request(
            hook_ctx=HookContext(
                operation_id="listAccounts", oauth2_scopes=[], security_source=security
            ),
            request=req,
            error_status_codes=["401", "403", "429", "4XX", "500", "504", "5XX"],
            retry_config=retry_config,
        )

        if utils.match_response(http_res, "200", "application/json"):
            return utils.unmarshal_json(http_res.text, List[models.Account])
        if utils.match_response(http_res, ["401", "403", "429", "4XX"], "*"):
            http_res_text = utils.stream_to_text(http_res)
            raise models.APIError(
                "API error occurred", http_res.status_code, http_res_text, http_res
            )
        if utils.match_response(http_res, ["500", "504", "5XX"], "*"):
            http_res_text = utils.stream_to_text(http_res)
            raise models.APIError(
                "API error occurred", http_res.status_code, http_res_text, http_res
            )

        content_type = http_res.headers.get("Content-Type")
        http_res_text = utils.stream_to_text(http_res)
        raise models.APIError(
            f"Unexpected response received (code: {http_res.status_code}, type: {content_type})",
            http_res.status_code,
            http_res_text,
            http_res,
        )

    async def list_accounts_async(
        self,
        *,
        security: Union[
            models.ListAccountsSecurity, models.ListAccountsSecurityTypedDict
        ],
        x_moov_version: Optional[models.Versions] = None,
        name: Optional[str] = None,
        email: Optional[str] = None,
        type_: Optional[models.AccountType] = None,
        foreign_id: Optional[str] = None,
        include_disconnected: Optional[bool] = None,
        capability: Optional[models.CapabilityID] = None,
        capability_status: Optional[models.CapabilityStatus] = None,
        skip: Optional[int] = None,
        count: Optional[int] = None,
        retries: OptionalNullable[utils.RetryConfig] = UNSET,
        server_url: Optional[str] = None,
        timeout_ms: Optional[int] = None,
        http_headers: Optional[Mapping[str, str]] = None,
    ) -> List[models.Account]:
        r"""List or search accounts to which the caller is connected.

        All supported query parameters are optional. If none are provided the response will include all connected accounts.
        Pagination is supported via the `skip` and `count` query parameters.
        Searching by name and email will overlap and return results based on relevance.

        :param security:
        :param x_moov_version: Specify an API version.
        :param name: Filter connected accounts by name.  If provided, this query will attempt to find matches against the following Account and Profile fields: <ul>   <li>Account `displayName`</li>   <li>Individual Profile `firstName`, `middleName`, and `lastName`</li>   <li>Business Profile `legalBusinessName`</li> </ul>
        :param email: Filter connected accounts by email address.    Provide the full email address to filter by email.
        :param type: Filter connected accounts by AccountType.    If the `type` parameter is used in combination with `name`, only the corresponding type's name fields will   be searched. For example, if `type=business` and `name=moov`, the search will attempt to find matches against   the display name and Business Profile name fields (`legalBusinessName`, and `doingBusinessAs`).
        :param foreign_id: Serves as an optional alias from a foreign/external system which can be used to reference this resource.
        :param include_disconnected: Filter disconnected accounts.  If true, the response will include disconnected accounts.
        :param capability: Filter connected accounts by the capability.
        :param capability_status: Filter connected accounts by the capability.
        :param skip:
        :param count:
        :param retries: Override the default retry configuration for this method
        :param server_url: Override the default server URL for this method
        :param timeout_ms: Override the default request timeout configuration for this method in milliseconds
        :param http_headers: Additional headers to set or replace on requests.
        """
        base_url = None
        url_variables = None
        if timeout_ms is None:
            timeout_ms = self.sdk_configuration.timeout_ms

        if server_url is not None:
            base_url = server_url

        request = models.ListAccountsRequest(
            x_moov_version=x_moov_version,
            name=name,
            email=email,
            type=type_,
            foreign_id=foreign_id,
            include_disconnected=include_disconnected,
            capability=capability,
            capability_status=capability_status,
            skip=skip,
            count=count,
        )

        req = self._build_request_async(
            method="GET",
            path="/accounts",
            base_url=base_url,
            url_variables=url_variables,
            request=request,
            request_body_required=False,
            request_has_path_params=False,
            request_has_query_params=True,
            user_agent_header="user-agent",
            accept_header_value="application/json",
            http_headers=http_headers,
            security=utils.get_pydantic_model(security, models.ListAccountsSecurity),
            timeout_ms=timeout_ms,
        )

        if retries == UNSET:
            if self.sdk_configuration.retry_config is not UNSET:
                retries = self.sdk_configuration.retry_config

        retry_config = None
        if isinstance(retries, utils.RetryConfig):
            retry_config = (retries, ["429", "500", "502", "503", "504"])

        http_res = await self.do_request_async(
            hook_ctx=HookContext(
                operation_id="listAccounts", oauth2_scopes=[], security_source=security
            ),
            request=req,
            error_status_codes=["401", "403", "429", "4XX", "500", "504", "5XX"],
            retry_config=retry_config,
        )

        if utils.match_response(http_res, "200", "application/json"):
            return utils.unmarshal_json(http_res.text, List[models.Account])
        if utils.match_response(http_res, ["401", "403", "429", "4XX"], "*"):
            http_res_text = await utils.stream_to_text_async(http_res)
            raise models.APIError(
                "API error occurred", http_res.status_code, http_res_text, http_res
            )
        if utils.match_response(http_res, ["500", "504", "5XX"], "*"):
            http_res_text = await utils.stream_to_text_async(http_res)
            raise models.APIError(
                "API error occurred", http_res.status_code, http_res_text, http_res
            )

        content_type = http_res.headers.get("Content-Type")
        http_res_text = await utils.stream_to_text_async(http_res)
        raise models.APIError(
            f"Unexpected response received (code: {http_res.status_code}, type: {content_type})",
            http_res.status_code,
            http_res_text,
            http_res,
        )

    def get_account(
        self,
        *,
        security: Union[models.GetAccountSecurity, models.GetAccountSecurityTypedDict],
        account_id: str,
        x_moov_version: Optional[models.Versions] = None,
        retries: OptionalNullable[utils.RetryConfig] = UNSET,
        server_url: Optional[str] = None,
        timeout_ms: Optional[int] = None,
        http_headers: Optional[Mapping[str, str]] = None,
    ) -> models.Account:
        r"""Retrieves details for the account with the specified ID.

        :param security:
        :param account_id:
        :param x_moov_version: Specify an API version.
        :param retries: Override the default retry configuration for this method
        :param server_url: Override the default server URL for this method
        :param timeout_ms: Override the default request timeout configuration for this method in milliseconds
        :param http_headers: Additional headers to set or replace on requests.
        """
        base_url = None
        url_variables = None
        if timeout_ms is None:
            timeout_ms = self.sdk_configuration.timeout_ms

        if server_url is not None:
            base_url = server_url

        request = models.GetAccountRequest(
            x_moov_version=x_moov_version,
            account_id=account_id,
        )

        req = self._build_request(
            method="GET",
            path="/accounts/{accountID}",
            base_url=base_url,
            url_variables=url_variables,
            request=request,
            request_body_required=False,
            request_has_path_params=True,
            request_has_query_params=True,
            user_agent_header="user-agent",
            accept_header_value="application/json",
            http_headers=http_headers,
            security=utils.get_pydantic_model(security, models.GetAccountSecurity),
            timeout_ms=timeout_ms,
        )

        if retries == UNSET:
            if self.sdk_configuration.retry_config is not UNSET:
                retries = self.sdk_configuration.retry_config

        retry_config = None
        if isinstance(retries, utils.RetryConfig):
            retry_config = (retries, ["429", "500", "502", "503", "504"])

        http_res = self.do_request(
            hook_ctx=HookContext(
                operation_id="getAccount", oauth2_scopes=[], security_source=security
            ),
            request=req,
            error_status_codes=["401", "403", "404", "429", "4XX", "500", "504", "5XX"],
            retry_config=retry_config,
        )

        if utils.match_response(http_res, "200", "application/json"):
            return utils.unmarshal_json(http_res.text, models.Account)
        if utils.match_response(http_res, ["401", "403", "404", "429", "4XX"], "*"):
            http_res_text = utils.stream_to_text(http_res)
            raise models.APIError(
                "API error occurred", http_res.status_code, http_res_text, http_res
            )
        if utils.match_response(http_res, ["500", "504", "5XX"], "*"):
            http_res_text = utils.stream_to_text(http_res)
            raise models.APIError(
                "API error occurred", http_res.status_code, http_res_text, http_res
            )

        content_type = http_res.headers.get("Content-Type")
        http_res_text = utils.stream_to_text(http_res)
        raise models.APIError(
            f"Unexpected response received (code: {http_res.status_code}, type: {content_type})",
            http_res.status_code,
            http_res_text,
            http_res,
        )

    async def get_account_async(
        self,
        *,
        security: Union[models.GetAccountSecurity, models.GetAccountSecurityTypedDict],
        account_id: str,
        x_moov_version: Optional[models.Versions] = None,
        retries: OptionalNullable[utils.RetryConfig] = UNSET,
        server_url: Optional[str] = None,
        timeout_ms: Optional[int] = None,
        http_headers: Optional[Mapping[str, str]] = None,
    ) -> models.Account:
        r"""Retrieves details for the account with the specified ID.

        :param security:
        :param account_id:
        :param x_moov_version: Specify an API version.
        :param retries: Override the default retry configuration for this method
        :param server_url: Override the default server URL for this method
        :param timeout_ms: Override the default request timeout configuration for this method in milliseconds
        :param http_headers: Additional headers to set or replace on requests.
        """
        base_url = None
        url_variables = None
        if timeout_ms is None:
            timeout_ms = self.sdk_configuration.timeout_ms

        if server_url is not None:
            base_url = server_url

        request = models.GetAccountRequest(
            x_moov_version=x_moov_version,
            account_id=account_id,
        )

        req = self._build_request_async(
            method="GET",
            path="/accounts/{accountID}",
            base_url=base_url,
            url_variables=url_variables,
            request=request,
            request_body_required=False,
            request_has_path_params=True,
            request_has_query_params=True,
            user_agent_header="user-agent",
            accept_header_value="application/json",
            http_headers=http_headers,
            security=utils.get_pydantic_model(security, models.GetAccountSecurity),
            timeout_ms=timeout_ms,
        )

        if retries == UNSET:
            if self.sdk_configuration.retry_config is not UNSET:
                retries = self.sdk_configuration.retry_config

        retry_config = None
        if isinstance(retries, utils.RetryConfig):
            retry_config = (retries, ["429", "500", "502", "503", "504"])

        http_res = await self.do_request_async(
            hook_ctx=HookContext(
                operation_id="getAccount", oauth2_scopes=[], security_source=security
            ),
            request=req,
            error_status_codes=["401", "403", "404", "429", "4XX", "500", "504", "5XX"],
            retry_config=retry_config,
        )

        if utils.match_response(http_res, "200", "application/json"):
            return utils.unmarshal_json(http_res.text, models.Account)
        if utils.match_response(http_res, ["401", "403", "404", "429", "4XX"], "*"):
            http_res_text = await utils.stream_to_text_async(http_res)
            raise models.APIError(
                "API error occurred", http_res.status_code, http_res_text, http_res
            )
        if utils.match_response(http_res, ["500", "504", "5XX"], "*"):
            http_res_text = await utils.stream_to_text_async(http_res)
            raise models.APIError(
                "API error occurred", http_res.status_code, http_res_text, http_res
            )

        content_type = http_res.headers.get("Content-Type")
        http_res_text = await utils.stream_to_text_async(http_res)
        raise models.APIError(
            f"Unexpected response received (code: {http_res.status_code}, type: {content_type})",
            http_res.status_code,
            http_res_text,
            http_res,
        )

    def patch_account(
        self,
        *,
        security: Union[
            models.PatchAccountSecurity, models.PatchAccountSecurityTypedDict
        ],
        account_id: str,
        x_moov_version: Optional[models.Versions] = None,
        account_type: Optional[models.AccountType] = None,
        profile: Optional[
            Union[models.CreateProfileUpdate, models.CreateProfileUpdateTypedDict]
        ] = None,
        metadata: Optional[Dict[str, str]] = None,
        terms_of_service: Optional[
            Union[
                models.CreateAccountUpdateTermsOfService,
                models.CreateAccountUpdateTermsOfServiceTypedDict,
            ]
        ] = None,
        foreign_id: Optional[str] = None,
        customer_support: Optional[
            Union[models.CustomerSupportUpdate, models.CustomerSupportUpdateTypedDict]
        ] = None,
        settings: Optional[
            Union[models.SettingsUpdate, models.SettingsUpdateTypedDict]
        ] = None,
        capabilities: Optional[List[models.CapabilityID]] = None,
        retries: OptionalNullable[utils.RetryConfig] = UNSET,
        server_url: Optional[str] = None,
        timeout_ms: Optional[int] = None,
        http_headers: Optional[Mapping[str, str]] = None,
    ) -> models.Account:
        r"""When **can** profile data be updated:
          + For unverified accounts, all profile data can be edited.
          + During the verification process, missing or incomplete profile data can be edited.
          + Verified accounts can only add missing profile data.

          When **can't** profile data be updated:
          + Verified accounts cannot change any existing profile data.

        If you need to update information in a locked state, please contact Moov support.

        To use this endpoint from the browser, you'll need to specify the `/accounts/{accountID}/profile.write` scope when generating
        a [token](https://docs.moov.io/api/authentication/access-tokens/), and provide the changed information.

        :param security:
        :param account_id:
        :param x_moov_version: Specify an API version.
        :param account_type: The type of entity represented by this account.
        :param profile:
        :param metadata: Free-form key-value pair list. Useful for storing information that is not captured elsewhere.
        :param terms_of_service:
        :param foreign_id: Optional alias from a foreign/external system which can be used to reference this resource.
        :param customer_support: User-provided information that can be displayed on credit card transactions for customers to use when contacting a customer support team. This data is only allowed on a business account.
        :param settings: User provided settings to manage an account.
        :param capabilities:
        :param retries: Override the default retry configuration for this method
        :param server_url: Override the default server URL for this method
        :param timeout_ms: Override the default request timeout configuration for this method in milliseconds
        :param http_headers: Additional headers to set or replace on requests.
        """
        base_url = None
        url_variables = None
        if timeout_ms is None:
            timeout_ms = self.sdk_configuration.timeout_ms

        if server_url is not None:
            base_url = server_url

        request = models.PatchAccountRequest(
            x_moov_version=x_moov_version,
            account_id=account_id,
            create_account_update=models.CreateAccountUpdate(
                account_type=account_type,
                profile=utils.get_pydantic_model(
                    profile, Optional[models.CreateProfileUpdate]
                ),
                metadata=metadata,
                terms_of_service=utils.get_pydantic_model(
                    terms_of_service, Optional[models.CreateAccountUpdateTermsOfService]
                ),
                foreign_id=foreign_id,
                customer_support=utils.get_pydantic_model(
                    customer_support, Optional[models.CustomerSupportUpdate]
                ),
                settings=utils.get_pydantic_model(
                    settings, Optional[models.SettingsUpdate]
                ),
                capabilities=capabilities,
            ),
        )

        req = self._build_request(
            method="PATCH",
            path="/accounts/{accountID}",
            base_url=base_url,
            url_variables=url_variables,
            request=request,
            request_body_required=True,
            request_has_path_params=True,
            request_has_query_params=True,
            user_agent_header="user-agent",
            accept_header_value="application/json",
            http_headers=http_headers,
            security=utils.get_pydantic_model(security, models.PatchAccountSecurity),
            get_serialized_body=lambda: utils.serialize_request_body(
                request.create_account_update,
                False,
                False,
                "json",
                models.CreateAccountUpdate,
            ),
            timeout_ms=timeout_ms,
        )

        if retries == UNSET:
            if self.sdk_configuration.retry_config is not UNSET:
                retries = self.sdk_configuration.retry_config

        retry_config = None
        if isinstance(retries, utils.RetryConfig):
            retry_config = (retries, ["429", "500", "502", "503", "504"])

        http_res = self.do_request(
            hook_ctx=HookContext(
                operation_id="patchAccount", oauth2_scopes=[], security_source=security
            ),
            request=req,
            error_status_codes=[
                "400",
                "401",
                "403",
                "404",
                "409",
                "422",
                "429",
                "4XX",
                "500",
                "504",
                "5XX",
            ],
            retry_config=retry_config,
        )

        data: Any = None
        if utils.match_response(http_res, "200", "application/json"):
            return utils.unmarshal_json(http_res.text, models.Account)
        if utils.match_response(http_res, ["400", "409"], "application/json"):
            data = utils.unmarshal_json(http_res.text, models.GenericErrorData)
            raise models.GenericError(data=data)
        if utils.match_response(http_res, ["401", "403", "404", "429", "4XX"], "*"):
            http_res_text = utils.stream_to_text(http_res)
            raise models.APIError(
                "API error occurred", http_res.status_code, http_res_text, http_res
            )
        if utils.match_response(http_res, "422", "application/json"):
            data = utils.unmarshal_json(
                http_res.text, models.PatchAccountResponseBodyData
            )
            raise models.PatchAccountResponseBody(data=data)
        if utils.match_response(http_res, ["500", "504", "5XX"], "*"):
            http_res_text = utils.stream_to_text(http_res)
            raise models.APIError(
                "API error occurred", http_res.status_code, http_res_text, http_res
            )

        content_type = http_res.headers.get("Content-Type")
        http_res_text = utils.stream_to_text(http_res)
        raise models.APIError(
            f"Unexpected response received (code: {http_res.status_code}, type: {content_type})",
            http_res.status_code,
            http_res_text,
            http_res,
        )

    async def patch_account_async(
        self,
        *,
        security: Union[
            models.PatchAccountSecurity, models.PatchAccountSecurityTypedDict
        ],
        account_id: str,
        x_moov_version: Optional[models.Versions] = None,
        account_type: Optional[models.AccountType] = None,
        profile: Optional[
            Union[models.CreateProfileUpdate, models.CreateProfileUpdateTypedDict]
        ] = None,
        metadata: Optional[Dict[str, str]] = None,
        terms_of_service: Optional[
            Union[
                models.CreateAccountUpdateTermsOfService,
                models.CreateAccountUpdateTermsOfServiceTypedDict,
            ]
        ] = None,
        foreign_id: Optional[str] = None,
        customer_support: Optional[
            Union[models.CustomerSupportUpdate, models.CustomerSupportUpdateTypedDict]
        ] = None,
        settings: Optional[
            Union[models.SettingsUpdate, models.SettingsUpdateTypedDict]
        ] = None,
        capabilities: Optional[List[models.CapabilityID]] = None,
        retries: OptionalNullable[utils.RetryConfig] = UNSET,
        server_url: Optional[str] = None,
        timeout_ms: Optional[int] = None,
        http_headers: Optional[Mapping[str, str]] = None,
    ) -> models.Account:
        r"""When **can** profile data be updated:
          + For unverified accounts, all profile data can be edited.
          + During the verification process, missing or incomplete profile data can be edited.
          + Verified accounts can only add missing profile data.

          When **can't** profile data be updated:
          + Verified accounts cannot change any existing profile data.

        If you need to update information in a locked state, please contact Moov support.

        To use this endpoint from the browser, you'll need to specify the `/accounts/{accountID}/profile.write` scope when generating
        a [token](https://docs.moov.io/api/authentication/access-tokens/), and provide the changed information.

        :param security:
        :param account_id:
        :param x_moov_version: Specify an API version.
        :param account_type: The type of entity represented by this account.
        :param profile:
        :param metadata: Free-form key-value pair list. Useful for storing information that is not captured elsewhere.
        :param terms_of_service:
        :param foreign_id: Optional alias from a foreign/external system which can be used to reference this resource.
        :param customer_support: User-provided information that can be displayed on credit card transactions for customers to use when contacting a customer support team. This data is only allowed on a business account.
        :param settings: User provided settings to manage an account.
        :param capabilities:
        :param retries: Override the default retry configuration for this method
        :param server_url: Override the default server URL for this method
        :param timeout_ms: Override the default request timeout configuration for this method in milliseconds
        :param http_headers: Additional headers to set or replace on requests.
        """
        base_url = None
        url_variables = None
        if timeout_ms is None:
            timeout_ms = self.sdk_configuration.timeout_ms

        if server_url is not None:
            base_url = server_url

        request = models.PatchAccountRequest(
            x_moov_version=x_moov_version,
            account_id=account_id,
            create_account_update=models.CreateAccountUpdate(
                account_type=account_type,
                profile=utils.get_pydantic_model(
                    profile, Optional[models.CreateProfileUpdate]
                ),
                metadata=metadata,
                terms_of_service=utils.get_pydantic_model(
                    terms_of_service, Optional[models.CreateAccountUpdateTermsOfService]
                ),
                foreign_id=foreign_id,
                customer_support=utils.get_pydantic_model(
                    customer_support, Optional[models.CustomerSupportUpdate]
                ),
                settings=utils.get_pydantic_model(
                    settings, Optional[models.SettingsUpdate]
                ),
                capabilities=capabilities,
            ),
        )

        req = self._build_request_async(
            method="PATCH",
            path="/accounts/{accountID}",
            base_url=base_url,
            url_variables=url_variables,
            request=request,
            request_body_required=True,
            request_has_path_params=True,
            request_has_query_params=True,
            user_agent_header="user-agent",
            accept_header_value="application/json",
            http_headers=http_headers,
            security=utils.get_pydantic_model(security, models.PatchAccountSecurity),
            get_serialized_body=lambda: utils.serialize_request_body(
                request.create_account_update,
                False,
                False,
                "json",
                models.CreateAccountUpdate,
            ),
            timeout_ms=timeout_ms,
        )

        if retries == UNSET:
            if self.sdk_configuration.retry_config is not UNSET:
                retries = self.sdk_configuration.retry_config

        retry_config = None
        if isinstance(retries, utils.RetryConfig):
            retry_config = (retries, ["429", "500", "502", "503", "504"])

        http_res = await self.do_request_async(
            hook_ctx=HookContext(
                operation_id="patchAccount", oauth2_scopes=[], security_source=security
            ),
            request=req,
            error_status_codes=[
                "400",
                "401",
                "403",
                "404",
                "409",
                "422",
                "429",
                "4XX",
                "500",
                "504",
                "5XX",
            ],
            retry_config=retry_config,
        )

        data: Any = None
        if utils.match_response(http_res, "200", "application/json"):
            return utils.unmarshal_json(http_res.text, models.Account)
        if utils.match_response(http_res, ["400", "409"], "application/json"):
            data = utils.unmarshal_json(http_res.text, models.GenericErrorData)
            raise models.GenericError(data=data)
        if utils.match_response(http_res, ["401", "403", "404", "429", "4XX"], "*"):
            http_res_text = await utils.stream_to_text_async(http_res)
            raise models.APIError(
                "API error occurred", http_res.status_code, http_res_text, http_res
            )
        if utils.match_response(http_res, "422", "application/json"):
            data = utils.unmarshal_json(
                http_res.text, models.PatchAccountResponseBodyData
            )
            raise models.PatchAccountResponseBody(data=data)
        if utils.match_response(http_res, ["500", "504", "5XX"], "*"):
            http_res_text = await utils.stream_to_text_async(http_res)
            raise models.APIError(
                "API error occurred", http_res.status_code, http_res_text, http_res
            )

        content_type = http_res.headers.get("Content-Type")
        http_res_text = await utils.stream_to_text_async(http_res)
        raise models.APIError(
            f"Unexpected response received (code: {http_res.status_code}, type: {content_type})",
            http_res.status_code,
            http_res_text,
            http_res,
        )

    def disconnect_account(
        self,
        *,
        security: Union[
            models.DisconnectAccountSecurity, models.DisconnectAccountSecurityTypedDict
        ],
        account_id: str,
        x_moov_version: Optional[models.Versions] = None,
        retries: OptionalNullable[utils.RetryConfig] = UNSET,
        server_url: Optional[str] = None,
        timeout_ms: Optional[int] = None,
        http_headers: Optional[Mapping[str, str]] = None,
    ):
        r"""This will sever the connection between you and the account specified and it will no longer be listed as active in the list of accounts.
          This also means you'll only have read-only access to the account going forward for reporting purposes.

          To use this endpoint from the browser, you'll need to specify the `/accounts/{accountID}/profile.disconnect` scope when generating
          a [token](https://docs.moov.io/api/authentication/access-tokens/), and provide the changed information.

        :param security:
        :param account_id:
        :param x_moov_version: Specify an API version.
        :param retries: Override the default retry configuration for this method
        :param server_url: Override the default server URL for this method
        :param timeout_ms: Override the default request timeout configuration for this method in milliseconds
        :param http_headers: Additional headers to set or replace on requests.
        """
        base_url = None
        url_variables = None
        if timeout_ms is None:
            timeout_ms = self.sdk_configuration.timeout_ms

        if server_url is not None:
            base_url = server_url

        request = models.DisconnectAccountRequest(
            x_moov_version=x_moov_version,
            account_id=account_id,
        )

        req = self._build_request(
            method="DELETE",
            path="/accounts/{accountID}",
            base_url=base_url,
            url_variables=url_variables,
            request=request,
            request_body_required=False,
            request_has_path_params=True,
            request_has_query_params=True,
            user_agent_header="user-agent",
            accept_header_value="application/json",
            http_headers=http_headers,
            security=utils.get_pydantic_model(
                security, models.DisconnectAccountSecurity
            ),
            timeout_ms=timeout_ms,
        )

        if retries == UNSET:
            if self.sdk_configuration.retry_config is not UNSET:
                retries = self.sdk_configuration.retry_config

        retry_config = None
        if isinstance(retries, utils.RetryConfig):
            retry_config = (retries, ["429", "500", "502", "503", "504"])

        http_res = self.do_request(
            hook_ctx=HookContext(
                operation_id="disconnectAccount",
                oauth2_scopes=[],
                security_source=security,
            ),
            request=req,
            error_status_codes=[
                "400",
                "401",
                "403",
                "404",
                "409",
                "429",
                "4XX",
                "500",
                "504",
                "5XX",
            ],
            retry_config=retry_config,
        )

        data: Any = None
        if utils.match_response(http_res, "204", "*"):
            return
        if utils.match_response(http_res, ["400", "409"], "application/json"):
            data = utils.unmarshal_json(http_res.text, models.GenericErrorData)
            raise models.GenericError(data=data)
        if utils.match_response(http_res, ["401", "403", "404", "429", "4XX"], "*"):
            http_res_text = utils.stream_to_text(http_res)
            raise models.APIError(
                "API error occurred", http_res.status_code, http_res_text, http_res
            )
        if utils.match_response(http_res, ["500", "504", "5XX"], "*"):
            http_res_text = utils.stream_to_text(http_res)
            raise models.APIError(
                "API error occurred", http_res.status_code, http_res_text, http_res
            )

        content_type = http_res.headers.get("Content-Type")
        http_res_text = utils.stream_to_text(http_res)
        raise models.APIError(
            f"Unexpected response received (code: {http_res.status_code}, type: {content_type})",
            http_res.status_code,
            http_res_text,
            http_res,
        )

    async def disconnect_account_async(
        self,
        *,
        security: Union[
            models.DisconnectAccountSecurity, models.DisconnectAccountSecurityTypedDict
        ],
        account_id: str,
        x_moov_version: Optional[models.Versions] = None,
        retries: OptionalNullable[utils.RetryConfig] = UNSET,
        server_url: Optional[str] = None,
        timeout_ms: Optional[int] = None,
        http_headers: Optional[Mapping[str, str]] = None,
    ):
        r"""This will sever the connection between you and the account specified and it will no longer be listed as active in the list of accounts.
          This also means you'll only have read-only access to the account going forward for reporting purposes.

          To use this endpoint from the browser, you'll need to specify the `/accounts/{accountID}/profile.disconnect` scope when generating
          a [token](https://docs.moov.io/api/authentication/access-tokens/), and provide the changed information.

        :param security:
        :param account_id:
        :param x_moov_version: Specify an API version.
        :param retries: Override the default retry configuration for this method
        :param server_url: Override the default server URL for this method
        :param timeout_ms: Override the default request timeout configuration for this method in milliseconds
        :param http_headers: Additional headers to set or replace on requests.
        """
        base_url = None
        url_variables = None
        if timeout_ms is None:
            timeout_ms = self.sdk_configuration.timeout_ms

        if server_url is not None:
            base_url = server_url

        request = models.DisconnectAccountRequest(
            x_moov_version=x_moov_version,
            account_id=account_id,
        )

        req = self._build_request_async(
            method="DELETE",
            path="/accounts/{accountID}",
            base_url=base_url,
            url_variables=url_variables,
            request=request,
            request_body_required=False,
            request_has_path_params=True,
            request_has_query_params=True,
            user_agent_header="user-agent",
            accept_header_value="application/json",
            http_headers=http_headers,
            security=utils.get_pydantic_model(
                security, models.DisconnectAccountSecurity
            ),
            timeout_ms=timeout_ms,
        )

        if retries == UNSET:
            if self.sdk_configuration.retry_config is not UNSET:
                retries = self.sdk_configuration.retry_config

        retry_config = None
        if isinstance(retries, utils.RetryConfig):
            retry_config = (retries, ["429", "500", "502", "503", "504"])

        http_res = await self.do_request_async(
            hook_ctx=HookContext(
                operation_id="disconnectAccount",
                oauth2_scopes=[],
                security_source=security,
            ),
            request=req,
            error_status_codes=[
                "400",
                "401",
                "403",
                "404",
                "409",
                "429",
                "4XX",
                "500",
                "504",
                "5XX",
            ],
            retry_config=retry_config,
        )

        data: Any = None
        if utils.match_response(http_res, "204", "*"):
            return
        if utils.match_response(http_res, ["400", "409"], "application/json"):
            data = utils.unmarshal_json(http_res.text, models.GenericErrorData)
            raise models.GenericError(data=data)
        if utils.match_response(http_res, ["401", "403", "404", "429", "4XX"], "*"):
            http_res_text = await utils.stream_to_text_async(http_res)
            raise models.APIError(
                "API error occurred", http_res.status_code, http_res_text, http_res
            )
        if utils.match_response(http_res, ["500", "504", "5XX"], "*"):
            http_res_text = await utils.stream_to_text_async(http_res)
            raise models.APIError(
                "API error occurred", http_res.status_code, http_res_text, http_res
            )

        content_type = http_res.headers.get("Content-Type")
        http_res_text = await utils.stream_to_text_async(http_res)
        raise models.APIError(
            f"Unexpected response received (code: {http_res.status_code}, type: {content_type})",
            http_res.status_code,
            http_res_text,
            http_res,
        )

    def get_account_countries(
        self,
        *,
        security: Union[
            models.GetAccountCountriesSecurity,
            models.GetAccountCountriesSecurityTypedDict,
        ],
        account_id: str,
        x_moov_version: Optional[models.Versions] = None,
        retries: OptionalNullable[utils.RetryConfig] = UNSET,
        server_url: Optional[str] = None,
        timeout_ms: Optional[int] = None,
        http_headers: Optional[Mapping[str, str]] = None,
    ) -> models.AccountCountries:
        r"""Retrieve the specified countries of operation for an account.

        To use this endpoint from the browser, you'll need to specify the `/accounts/{accountID}/profile.read` scope when generating
        a [token](https://docs.moov.io/api/authentication/access-tokens/).

        :param security:
        :param account_id:
        :param x_moov_version: Specify an API version.
        :param retries: Override the default retry configuration for this method
        :param server_url: Override the default server URL for this method
        :param timeout_ms: Override the default request timeout configuration for this method in milliseconds
        :param http_headers: Additional headers to set or replace on requests.
        """
        base_url = None
        url_variables = None
        if timeout_ms is None:
            timeout_ms = self.sdk_configuration.timeout_ms

        if server_url is not None:
            base_url = server_url

        request = models.GetAccountCountriesRequest(
            x_moov_version=x_moov_version,
            account_id=account_id,
        )

        req = self._build_request(
            method="GET",
            path="/accounts/{accountID}/countries",
            base_url=base_url,
            url_variables=url_variables,
            request=request,
            request_body_required=False,
            request_has_path_params=True,
            request_has_query_params=True,
            user_agent_header="user-agent",
            accept_header_value="application/json",
            http_headers=http_headers,
            security=utils.get_pydantic_model(
                security, models.GetAccountCountriesSecurity
            ),
            timeout_ms=timeout_ms,
        )

        if retries == UNSET:
            if self.sdk_configuration.retry_config is not UNSET:
                retries = self.sdk_configuration.retry_config

        retry_config = None
        if isinstance(retries, utils.RetryConfig):
            retry_config = (retries, ["429", "500", "502", "503", "504"])

        http_res = self.do_request(
            hook_ctx=HookContext(
                operation_id="getAccountCountries",
                oauth2_scopes=[],
                security_source=security,
            ),
            request=req,
            error_status_codes=["401", "403", "404", "429", "4XX", "500", "504", "5XX"],
            retry_config=retry_config,
        )

        if utils.match_response(http_res, "200", "application/json"):
            return utils.unmarshal_json(http_res.text, models.AccountCountries)
        if utils.match_response(http_res, ["401", "403", "404", "429", "4XX"], "*"):
            http_res_text = utils.stream_to_text(http_res)
            raise models.APIError(
                "API error occurred", http_res.status_code, http_res_text, http_res
            )
        if utils.match_response(http_res, ["500", "504", "5XX"], "*"):
            http_res_text = utils.stream_to_text(http_res)
            raise models.APIError(
                "API error occurred", http_res.status_code, http_res_text, http_res
            )

        content_type = http_res.headers.get("Content-Type")
        http_res_text = utils.stream_to_text(http_res)
        raise models.APIError(
            f"Unexpected response received (code: {http_res.status_code}, type: {content_type})",
            http_res.status_code,
            http_res_text,
            http_res,
        )

    async def get_account_countries_async(
        self,
        *,
        security: Union[
            models.GetAccountCountriesSecurity,
            models.GetAccountCountriesSecurityTypedDict,
        ],
        account_id: str,
        x_moov_version: Optional[models.Versions] = None,
        retries: OptionalNullable[utils.RetryConfig] = UNSET,
        server_url: Optional[str] = None,
        timeout_ms: Optional[int] = None,
        http_headers: Optional[Mapping[str, str]] = None,
    ) -> models.AccountCountries:
        r"""Retrieve the specified countries of operation for an account.

        To use this endpoint from the browser, you'll need to specify the `/accounts/{accountID}/profile.read` scope when generating
        a [token](https://docs.moov.io/api/authentication/access-tokens/).

        :param security:
        :param account_id:
        :param x_moov_version: Specify an API version.
        :param retries: Override the default retry configuration for this method
        :param server_url: Override the default server URL for this method
        :param timeout_ms: Override the default request timeout configuration for this method in milliseconds
        :param http_headers: Additional headers to set or replace on requests.
        """
        base_url = None
        url_variables = None
        if timeout_ms is None:
            timeout_ms = self.sdk_configuration.timeout_ms

        if server_url is not None:
            base_url = server_url

        request = models.GetAccountCountriesRequest(
            x_moov_version=x_moov_version,
            account_id=account_id,
        )

        req = self._build_request_async(
            method="GET",
            path="/accounts/{accountID}/countries",
            base_url=base_url,
            url_variables=url_variables,
            request=request,
            request_body_required=False,
            request_has_path_params=True,
            request_has_query_params=True,
            user_agent_header="user-agent",
            accept_header_value="application/json",
            http_headers=http_headers,
            security=utils.get_pydantic_model(
                security, models.GetAccountCountriesSecurity
            ),
            timeout_ms=timeout_ms,
        )

        if retries == UNSET:
            if self.sdk_configuration.retry_config is not UNSET:
                retries = self.sdk_configuration.retry_config

        retry_config = None
        if isinstance(retries, utils.RetryConfig):
            retry_config = (retries, ["429", "500", "502", "503", "504"])

        http_res = await self.do_request_async(
            hook_ctx=HookContext(
                operation_id="getAccountCountries",
                oauth2_scopes=[],
                security_source=security,
            ),
            request=req,
            error_status_codes=["401", "403", "404", "429", "4XX", "500", "504", "5XX"],
            retry_config=retry_config,
        )

        if utils.match_response(http_res, "200", "application/json"):
            return utils.unmarshal_json(http_res.text, models.AccountCountries)
        if utils.match_response(http_res, ["401", "403", "404", "429", "4XX"], "*"):
            http_res_text = await utils.stream_to_text_async(http_res)
            raise models.APIError(
                "API error occurred", http_res.status_code, http_res_text, http_res
            )
        if utils.match_response(http_res, ["500", "504", "5XX"], "*"):
            http_res_text = await utils.stream_to_text_async(http_res)
            raise models.APIError(
                "API error occurred", http_res.status_code, http_res_text, http_res
            )

        content_type = http_res.headers.get("Content-Type")
        http_res_text = await utils.stream_to_text_async(http_res)
        raise models.APIError(
            f"Unexpected response received (code: {http_res.status_code}, type: {content_type})",
            http_res.status_code,
            http_res_text,
            http_res,
        )

    def assign_account_countries(
        self,
        *,
        security: Union[
            models.AssignAccountCountriesSecurity,
            models.AssignAccountCountriesSecurityTypedDict,
        ],
        account_id: str,
        countries: List[str],
        x_moov_version: Optional[models.Versions] = None,
        retries: OptionalNullable[utils.RetryConfig] = UNSET,
        server_url: Optional[str] = None,
        timeout_ms: Optional[int] = None,
        http_headers: Optional[Mapping[str, str]] = None,
    ) -> models.AccountCountries:
        r"""Assign the countries of operation for an account.

        This endpoint will always overwrite the previously assigned values.

        To use this endpoint from the browser, you'll need to specify the `/accounts/{accountID}/profile.write` scope when generating
        a [token](https://docs.moov.io/api/authentication/access-tokens/).

        :param security:
        :param account_id:
        :param countries:
        :param x_moov_version: Specify an API version.
        :param retries: Override the default retry configuration for this method
        :param server_url: Override the default server URL for this method
        :param timeout_ms: Override the default request timeout configuration for this method in milliseconds
        :param http_headers: Additional headers to set or replace on requests.
        """
        base_url = None
        url_variables = None
        if timeout_ms is None:
            timeout_ms = self.sdk_configuration.timeout_ms

        if server_url is not None:
            base_url = server_url

        request = models.AssignAccountCountriesRequest(
            x_moov_version=x_moov_version,
            account_id=account_id,
            account_countries=models.AccountCountries(
                countries=countries,
            ),
        )

        req = self._build_request(
            method="PUT",
            path="/accounts/{accountID}/countries",
            base_url=base_url,
            url_variables=url_variables,
            request=request,
            request_body_required=True,
            request_has_path_params=True,
            request_has_query_params=True,
            user_agent_header="user-agent",
            accept_header_value="application/json",
            http_headers=http_headers,
            security=utils.get_pydantic_model(
                security, models.AssignAccountCountriesSecurity
            ),
            get_serialized_body=lambda: utils.serialize_request_body(
                request.account_countries, False, False, "json", models.AccountCountries
            ),
            timeout_ms=timeout_ms,
        )

        if retries == UNSET:
            if self.sdk_configuration.retry_config is not UNSET:
                retries = self.sdk_configuration.retry_config

        retry_config = None
        if isinstance(retries, utils.RetryConfig):
            retry_config = (retries, ["429", "500", "502", "503", "504"])

        http_res = self.do_request(
            hook_ctx=HookContext(
                operation_id="assignAccountCountries",
                oauth2_scopes=[],
                security_source=security,
            ),
            request=req,
            error_status_codes=[
                "400",
                "401",
                "403",
                "404",
                "409",
                "422",
                "429",
                "4XX",
                "500",
                "504",
                "5XX",
            ],
            retry_config=retry_config,
        )

        data: Any = None
        if utils.match_response(http_res, "200", "application/json"):
            return utils.unmarshal_json(http_res.text, models.AccountCountries)
        if utils.match_response(http_res, ["400", "409"], "application/json"):
            data = utils.unmarshal_json(http_res.text, models.GenericErrorData)
            raise models.GenericError(data=data)
        if utils.match_response(http_res, ["401", "403", "404", "429", "4XX"], "*"):
            http_res_text = utils.stream_to_text(http_res)
            raise models.APIError(
                "API error occurred", http_res.status_code, http_res_text, http_res
            )
        if utils.match_response(http_res, "422", "application/json"):
            data = utils.unmarshal_json(http_res.text, models.AssignCountriesErrorData)
            raise models.AssignCountriesError(data=data)
        if utils.match_response(http_res, ["500", "504", "5XX"], "*"):
            http_res_text = utils.stream_to_text(http_res)
            raise models.APIError(
                "API error occurred", http_res.status_code, http_res_text, http_res
            )

        content_type = http_res.headers.get("Content-Type")
        http_res_text = utils.stream_to_text(http_res)
        raise models.APIError(
            f"Unexpected response received (code: {http_res.status_code}, type: {content_type})",
            http_res.status_code,
            http_res_text,
            http_res,
        )

    async def assign_account_countries_async(
        self,
        *,
        security: Union[
            models.AssignAccountCountriesSecurity,
            models.AssignAccountCountriesSecurityTypedDict,
        ],
        account_id: str,
        countries: List[str],
        x_moov_version: Optional[models.Versions] = None,
        retries: OptionalNullable[utils.RetryConfig] = UNSET,
        server_url: Optional[str] = None,
        timeout_ms: Optional[int] = None,
        http_headers: Optional[Mapping[str, str]] = None,
    ) -> models.AccountCountries:
        r"""Assign the countries of operation for an account.

        This endpoint will always overwrite the previously assigned values.

        To use this endpoint from the browser, you'll need to specify the `/accounts/{accountID}/profile.write` scope when generating
        a [token](https://docs.moov.io/api/authentication/access-tokens/).

        :param security:
        :param account_id:
        :param countries:
        :param x_moov_version: Specify an API version.
        :param retries: Override the default retry configuration for this method
        :param server_url: Override the default server URL for this method
        :param timeout_ms: Override the default request timeout configuration for this method in milliseconds
        :param http_headers: Additional headers to set or replace on requests.
        """
        base_url = None
        url_variables = None
        if timeout_ms is None:
            timeout_ms = self.sdk_configuration.timeout_ms

        if server_url is not None:
            base_url = server_url

        request = models.AssignAccountCountriesRequest(
            x_moov_version=x_moov_version,
            account_id=account_id,
            account_countries=models.AccountCountries(
                countries=countries,
            ),
        )

        req = self._build_request_async(
            method="PUT",
            path="/accounts/{accountID}/countries",
            base_url=base_url,
            url_variables=url_variables,
            request=request,
            request_body_required=True,
            request_has_path_params=True,
            request_has_query_params=True,
            user_agent_header="user-agent",
            accept_header_value="application/json",
            http_headers=http_headers,
            security=utils.get_pydantic_model(
                security, models.AssignAccountCountriesSecurity
            ),
            get_serialized_body=lambda: utils.serialize_request_body(
                request.account_countries, False, False, "json", models.AccountCountries
            ),
            timeout_ms=timeout_ms,
        )

        if retries == UNSET:
            if self.sdk_configuration.retry_config is not UNSET:
                retries = self.sdk_configuration.retry_config

        retry_config = None
        if isinstance(retries, utils.RetryConfig):
            retry_config = (retries, ["429", "500", "502", "503", "504"])

        http_res = await self.do_request_async(
            hook_ctx=HookContext(
                operation_id="assignAccountCountries",
                oauth2_scopes=[],
                security_source=security,
            ),
            request=req,
            error_status_codes=[
                "400",
                "401",
                "403",
                "404",
                "409",
                "422",
                "429",
                "4XX",
                "500",
                "504",
                "5XX",
            ],
            retry_config=retry_config,
        )

        data: Any = None
        if utils.match_response(http_res, "200", "application/json"):
            return utils.unmarshal_json(http_res.text, models.AccountCountries)
        if utils.match_response(http_res, ["400", "409"], "application/json"):
            data = utils.unmarshal_json(http_res.text, models.GenericErrorData)
            raise models.GenericError(data=data)
        if utils.match_response(http_res, ["401", "403", "404", "429", "4XX"], "*"):
            http_res_text = await utils.stream_to_text_async(http_res)
            raise models.APIError(
                "API error occurred", http_res.status_code, http_res_text, http_res
            )
        if utils.match_response(http_res, "422", "application/json"):
            data = utils.unmarshal_json(http_res.text, models.AssignCountriesErrorData)
            raise models.AssignCountriesError(data=data)
        if utils.match_response(http_res, ["500", "504", "5XX"], "*"):
            http_res_text = await utils.stream_to_text_async(http_res)
            raise models.APIError(
                "API error occurred", http_res.status_code, http_res_text, http_res
            )

        content_type = http_res.headers.get("Content-Type")
        http_res_text = await utils.stream_to_text_async(http_res)
        raise models.APIError(
            f"Unexpected response received (code: {http_res.status_code}, type: {content_type})",
            http_res.status_code,
            http_res_text,
            http_res,
        )

    def get_merchant_processing_agreement(
        self,
        *,
        security: Union[
            models.GetMerchantProcessingAgreementSecurity,
            models.GetMerchantProcessingAgreementSecurityTypedDict,
        ],
        account_id: str,
        x_moov_version: Optional[models.Versions] = None,
        retries: OptionalNullable[utils.RetryConfig] = UNSET,
        server_url: Optional[str] = None,
        timeout_ms: Optional[int] = None,
        http_headers: Optional[Mapping[str, str]] = None,
    ) -> httpx.Response:
        r"""Retrieve a merchant account's processing agreement.

        To access this endpoint using a [token](https://docs.moov.io/api/authentication/access-tokens/) you'll need
        to specify the `/accounts/{accountID}/profile.read` scope.

        :param security:
        :param account_id:
        :param x_moov_version: Specify an API version.
        :param retries: Override the default retry configuration for this method
        :param server_url: Override the default server URL for this method
        :param timeout_ms: Override the default request timeout configuration for this method in milliseconds
        :param http_headers: Additional headers to set or replace on requests.
        """
        base_url = None
        url_variables = None
        if timeout_ms is None:
            timeout_ms = self.sdk_configuration.timeout_ms

        if server_url is not None:
            base_url = server_url

        request = models.GetMerchantProcessingAgreementRequest(
            x_moov_version=x_moov_version,
            account_id=account_id,
        )

        req = self._build_request(
            method="GET",
            path="/accounts/{accountID}/merchant-agreement",
            base_url=base_url,
            url_variables=url_variables,
            request=request,
            request_body_required=False,
            request_has_path_params=True,
            request_has_query_params=True,
            user_agent_header="user-agent",
            accept_header_value="application/pdf",
            http_headers=http_headers,
            security=utils.get_pydantic_model(
                security, models.GetMerchantProcessingAgreementSecurity
            ),
            timeout_ms=timeout_ms,
        )

        if retries == UNSET:
            if self.sdk_configuration.retry_config is not UNSET:
                retries = self.sdk_configuration.retry_config

        retry_config = None
        if isinstance(retries, utils.RetryConfig):
            retry_config = (retries, ["429", "500", "502", "503", "504"])

        http_res = self.do_request(
            hook_ctx=HookContext(
                operation_id="getMerchantProcessingAgreement",
                oauth2_scopes=[],
                security_source=security,
            ),
            request=req,
            error_status_codes=["401", "403", "404", "429", "4XX", "500", "504", "5XX"],
            stream=True,
            retry_config=retry_config,
        )

        if utils.match_response(http_res, "200", "application/pdf"):
            return http_res
        if utils.match_response(http_res, ["401", "403", "404", "429", "4XX"], "*"):
            http_res_text = utils.stream_to_text(http_res)
            raise models.APIError(
                "API error occurred", http_res.status_code, http_res_text, http_res
            )
        if utils.match_response(http_res, ["500", "504", "5XX"], "*"):
            http_res_text = utils.stream_to_text(http_res)
            raise models.APIError(
                "API error occurred", http_res.status_code, http_res_text, http_res
            )

        content_type = http_res.headers.get("Content-Type")
        http_res_text = utils.stream_to_text(http_res)
        raise models.APIError(
            f"Unexpected response received (code: {http_res.status_code}, type: {content_type})",
            http_res.status_code,
            http_res_text,
            http_res,
        )

    async def get_merchant_processing_agreement_async(
        self,
        *,
        security: Union[
            models.GetMerchantProcessingAgreementSecurity,
            models.GetMerchantProcessingAgreementSecurityTypedDict,
        ],
        account_id: str,
        x_moov_version: Optional[models.Versions] = None,
        retries: OptionalNullable[utils.RetryConfig] = UNSET,
        server_url: Optional[str] = None,
        timeout_ms: Optional[int] = None,
        http_headers: Optional[Mapping[str, str]] = None,
    ) -> httpx.Response:
        r"""Retrieve a merchant account's processing agreement.

        To access this endpoint using a [token](https://docs.moov.io/api/authentication/access-tokens/) you'll need
        to specify the `/accounts/{accountID}/profile.read` scope.

        :param security:
        :param account_id:
        :param x_moov_version: Specify an API version.
        :param retries: Override the default retry configuration for this method
        :param server_url: Override the default server URL for this method
        :param timeout_ms: Override the default request timeout configuration for this method in milliseconds
        :param http_headers: Additional headers to set or replace on requests.
        """
        base_url = None
        url_variables = None
        if timeout_ms is None:
            timeout_ms = self.sdk_configuration.timeout_ms

        if server_url is not None:
            base_url = server_url

        request = models.GetMerchantProcessingAgreementRequest(
            x_moov_version=x_moov_version,
            account_id=account_id,
        )

        req = self._build_request_async(
            method="GET",
            path="/accounts/{accountID}/merchant-agreement",
            base_url=base_url,
            url_variables=url_variables,
            request=request,
            request_body_required=False,
            request_has_path_params=True,
            request_has_query_params=True,
            user_agent_header="user-agent",
            accept_header_value="application/pdf",
            http_headers=http_headers,
            security=utils.get_pydantic_model(
                security, models.GetMerchantProcessingAgreementSecurity
            ),
            timeout_ms=timeout_ms,
        )

        if retries == UNSET:
            if self.sdk_configuration.retry_config is not UNSET:
                retries = self.sdk_configuration.retry_config

        retry_config = None
        if isinstance(retries, utils.RetryConfig):
            retry_config = (retries, ["429", "500", "502", "503", "504"])

        http_res = await self.do_request_async(
            hook_ctx=HookContext(
                operation_id="getMerchantProcessingAgreement",
                oauth2_scopes=[],
                security_source=security,
            ),
            request=req,
            error_status_codes=["401", "403", "404", "429", "4XX", "500", "504", "5XX"],
            stream=True,
            retry_config=retry_config,
        )

        if utils.match_response(http_res, "200", "application/pdf"):
            return http_res
        if utils.match_response(http_res, ["401", "403", "404", "429", "4XX"], "*"):
            http_res_text = await utils.stream_to_text_async(http_res)
            raise models.APIError(
                "API error occurred", http_res.status_code, http_res_text, http_res
            )
        if utils.match_response(http_res, ["500", "504", "5XX"], "*"):
            http_res_text = await utils.stream_to_text_async(http_res)
            raise models.APIError(
                "API error occurred", http_res.status_code, http_res_text, http_res
            )

        content_type = http_res.headers.get("Content-Type")
        http_res_text = await utils.stream_to_text_async(http_res)
        raise models.APIError(
            f"Unexpected response received (code: {http_res.status_code}, type: {content_type})",
            http_res.status_code,
            http_res_text,
            http_res,
        )

    def get_terms_of_service_token(
        self,
        *,
        x_moov_version: Optional[models.Versions] = None,
        origin: Optional[str] = None,
        referer: Optional[str] = None,
        retries: OptionalNullable[utils.RetryConfig] = UNSET,
        server_url: Optional[str] = None,
        timeout_ms: Optional[int] = None,
        http_headers: Optional[Mapping[str, str]] = None,
    ) -> models.TermsOfServiceToken:
        r"""Generates a non-expiring token that can then be used to accept Moovs terms of service.

          This token can only be generated via API. Any Moov account requesting the collect funds, send funds, wallet, or card issuing capabilities
          must accept Moovs terms of service, then have the generated terms of service token patched to the account. Read more in our [documentation](https://docs.moov.io/guides/accounts/requirements/platform-agreement/).

        :param x_moov_version: Specify an API version.
        :param origin: Indicates the domain from which the request originated. Required if referer header is not present.
        :param referer: Specifies the URL of the resource from which the request originated. Required if origin header is not present.
        :param retries: Override the default retry configuration for this method
        :param server_url: Override the default server URL for this method
        :param timeout_ms: Override the default request timeout configuration for this method in milliseconds
        :param http_headers: Additional headers to set or replace on requests.
        """
        base_url = None
        url_variables = None
        if timeout_ms is None:
            timeout_ms = self.sdk_configuration.timeout_ms

        if server_url is not None:
            base_url = server_url

        request = models.GetTermsOfServiceTokenRequest(
            x_moov_version=x_moov_version,
            origin=origin,
            referer=referer,
        )

        req = self._build_request(
            method="GET",
            path="/tos-token",
            base_url=base_url,
            url_variables=url_variables,
            request=request,
            request_body_required=False,
            request_has_path_params=False,
            request_has_query_params=True,
            user_agent_header="user-agent",
            accept_header_value="application/json",
            http_headers=http_headers,
            security=self.sdk_configuration.security,
            timeout_ms=timeout_ms,
        )

        if retries == UNSET:
            if self.sdk_configuration.retry_config is not UNSET:
                retries = self.sdk_configuration.retry_config

        retry_config = None
        if isinstance(retries, utils.RetryConfig):
            retry_config = (retries, ["429", "500", "502", "503", "504"])

        http_res = self.do_request(
            hook_ctx=HookContext(
                operation_id="getTermsOfServiceToken",
                oauth2_scopes=[],
                security_source=self.sdk_configuration.security,
            ),
            request=req,
            error_status_codes=["401", "403", "404", "429", "4XX", "500", "504", "5XX"],
            retry_config=retry_config,
        )

        if utils.match_response(http_res, "200", "application/json"):
            return utils.unmarshal_json(http_res.text, models.TermsOfServiceToken)
        if utils.match_response(http_res, ["401", "403", "404", "429", "4XX"], "*"):
            http_res_text = utils.stream_to_text(http_res)
            raise models.APIError(
                "API error occurred", http_res.status_code, http_res_text, http_res
            )
        if utils.match_response(http_res, ["500", "504", "5XX"], "*"):
            http_res_text = utils.stream_to_text(http_res)
            raise models.APIError(
                "API error occurred", http_res.status_code, http_res_text, http_res
            )

        content_type = http_res.headers.get("Content-Type")
        http_res_text = utils.stream_to_text(http_res)
        raise models.APIError(
            f"Unexpected response received (code: {http_res.status_code}, type: {content_type})",
            http_res.status_code,
            http_res_text,
            http_res,
        )

    async def get_terms_of_service_token_async(
        self,
        *,
        x_moov_version: Optional[models.Versions] = None,
        origin: Optional[str] = None,
        referer: Optional[str] = None,
        retries: OptionalNullable[utils.RetryConfig] = UNSET,
        server_url: Optional[str] = None,
        timeout_ms: Optional[int] = None,
        http_headers: Optional[Mapping[str, str]] = None,
    ) -> models.TermsOfServiceToken:
        r"""Generates a non-expiring token that can then be used to accept Moovs terms of service.

          This token can only be generated via API. Any Moov account requesting the collect funds, send funds, wallet, or card issuing capabilities
          must accept Moovs terms of service, then have the generated terms of service token patched to the account. Read more in our [documentation](https://docs.moov.io/guides/accounts/requirements/platform-agreement/).

        :param x_moov_version: Specify an API version.
        :param origin: Indicates the domain from which the request originated. Required if referer header is not present.
        :param referer: Specifies the URL of the resource from which the request originated. Required if origin header is not present.
        :param retries: Override the default retry configuration for this method
        :param server_url: Override the default server URL for this method
        :param timeout_ms: Override the default request timeout configuration for this method in milliseconds
        :param http_headers: Additional headers to set or replace on requests.
        """
        base_url = None
        url_variables = None
        if timeout_ms is None:
            timeout_ms = self.sdk_configuration.timeout_ms

        if server_url is not None:
            base_url = server_url

        request = models.GetTermsOfServiceTokenRequest(
            x_moov_version=x_moov_version,
            origin=origin,
            referer=referer,
        )

        req = self._build_request_async(
            method="GET",
            path="/tos-token",
            base_url=base_url,
            url_variables=url_variables,
            request=request,
            request_body_required=False,
            request_has_path_params=False,
            request_has_query_params=True,
            user_agent_header="user-agent",
            accept_header_value="application/json",
            http_headers=http_headers,
            security=self.sdk_configuration.security,
            timeout_ms=timeout_ms,
        )

        if retries == UNSET:
            if self.sdk_configuration.retry_config is not UNSET:
                retries = self.sdk_configuration.retry_config

        retry_config = None
        if isinstance(retries, utils.RetryConfig):
            retry_config = (retries, ["429", "500", "502", "503", "504"])

        http_res = await self.do_request_async(
            hook_ctx=HookContext(
                operation_id="getTermsOfServiceToken",
                oauth2_scopes=[],
                security_source=self.sdk_configuration.security,
            ),
            request=req,
            error_status_codes=["401", "403", "404", "429", "4XX", "500", "504", "5XX"],
            retry_config=retry_config,
        )

        if utils.match_response(http_res, "200", "application/json"):
            return utils.unmarshal_json(http_res.text, models.TermsOfServiceToken)
        if utils.match_response(http_res, ["401", "403", "404", "429", "4XX"], "*"):
            http_res_text = await utils.stream_to_text_async(http_res)
            raise models.APIError(
                "API error occurred", http_res.status_code, http_res_text, http_res
            )
        if utils.match_response(http_res, ["500", "504", "5XX"], "*"):
            http_res_text = await utils.stream_to_text_async(http_res)
            raise models.APIError(
                "API error occurred", http_res.status_code, http_res_text, http_res
            )

        content_type = http_res.headers.get("Content-Type")
        http_res_text = await utils.stream_to_text_async(http_res)
        raise models.APIError(
            f"Unexpected response received (code: {http_res.status_code}, type: {content_type})",
            http_res.status_code,
            http_res_text,
            http_res,
        )
