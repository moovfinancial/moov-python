"""Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT."""

from .basesdk import BaseSDK
from datetime import datetime
from moov import models, utils
from moov._hooks import HookContext
from moov.types import OptionalNullable, UNSET
from typing import Any, Dict, List, Mapping, Optional, Union


class Transfers(BaseSDK):
    def create_transfer(
        self,
        *,
        security: Union[
            models.CreateTransferSecurity, models.CreateTransferSecurityTypedDict
        ],
        x_idempotency_key: str,
        account_id: str,
        source: Union[
            models.CreateTransferSource, models.CreateTransferSourceTypedDict
        ],
        destination: Union[
            models.CreateTransferDestination, models.CreateTransferDestinationTypedDict
        ],
        amount: Union[models.Amount, models.AmountTypedDict],
        x_moov_version: Optional[models.Versions] = None,
        x_wait_for: Optional[models.TransferWaitFor] = None,
        facilitator_fee: Optional[
            Union[models.FacilitatorFee, models.FacilitatorFeeTypedDict]
        ] = None,
        description: Optional[str] = None,
        metadata: Optional[Dict[str, str]] = None,
        retries: OptionalNullable[utils.RetryConfig] = UNSET,
        server_url: Optional[str] = None,
        timeout_ms: Optional[int] = None,
        http_headers: Optional[Mapping[str, str]] = None,
    ) -> models.CreateTransferResponse:
        r"""Move money by providing the source, destination, and amount in the request body.

        Read our [transfers overview guide](https://docs.moov.io/guides/money-movement/overview/) to learn more.

        To access this endpoint using a [token](https://docs.moov.io/api/authentication/access-tokens/) you'll need to specify the `/accounts/{accountID}/transfers.write`
        scope.

        :param security:
        :param x_idempotency_key: Prevents duplicate transfers from being created.
        :param account_id: The merchant's Moov account ID.
        :param source: Where funds for a transfer originate. For the source, you must include either a `paymentMethodID` or a `transferID`.
        :param destination: The final stage of a transfer and the ultimate recipient of the funds.
        :param amount:
        :param x_moov_version: Specify an API version.
        :param x_wait_for: Optional header that indicates whether to return a synchronous response that includes full transfer and rail-specific details or an  asynchronous response indicating the transfer was created (this is the default response if the header is omitted).
        :param facilitator_fee: Total or markup fee.
        :param description: An optional description of the transfer for your own internal use.
        :param metadata: Free-form key-value pair list. Useful for storing information that is not captured elsewhere.
        :param retries: Override the default retry configuration for this method
        :param server_url: Override the default server URL for this method
        :param timeout_ms: Override the default request timeout configuration for this method in milliseconds
        :param http_headers: Additional headers to set or replace on requests.
        """
        base_url = None
        url_variables = None
        if timeout_ms is None:
            timeout_ms = self.sdk_configuration.timeout_ms

        if server_url is not None:
            base_url = server_url

        request = models.CreateTransferRequest(
            x_moov_version=x_moov_version,
            x_idempotency_key=x_idempotency_key,
            x_wait_for=x_wait_for,
            account_id=account_id,
            create_transfer=models.CreateTransfer(
                source=utils.get_pydantic_model(source, models.CreateTransferSource),
                destination=utils.get_pydantic_model(
                    destination, models.CreateTransferDestination
                ),
                amount=utils.get_pydantic_model(amount, models.Amount),
                facilitator_fee=utils.get_pydantic_model(
                    facilitator_fee, Optional[models.FacilitatorFee]
                ),
                description=description,
                metadata=metadata,
            ),
        )

        req = self._build_request(
            method="POST",
            path="/accounts/{accountID}/transfers",
            base_url=base_url,
            url_variables=url_variables,
            request=request,
            request_body_required=True,
            request_has_path_params=True,
            request_has_query_params=True,
            user_agent_header="user-agent",
            accept_header_value="application/json",
            http_headers=http_headers,
            security=utils.get_pydantic_model(security, models.CreateTransferSecurity),
            get_serialized_body=lambda: utils.serialize_request_body(
                request.create_transfer, False, False, "json", models.CreateTransfer
            ),
            timeout_ms=timeout_ms,
        )

        if retries == UNSET:
            if self.sdk_configuration.retry_config is not UNSET:
                retries = self.sdk_configuration.retry_config

        retry_config = None
        if isinstance(retries, utils.RetryConfig):
            retry_config = (retries, ["429", "500", "502", "503", "504"])

        http_res = self.do_request(
            hook_ctx=HookContext(
                operation_id="createTransfer",
                oauth2_scopes=[],
                security_source=security,
            ),
            request=req,
            error_status_codes=[
                "400",
                "404",
                "409",
                "422",
                "429",
                "4XX",
                "500",
                "504",
                "5XX",
            ],
            retry_config=retry_config,
        )

        data: Any = None
        if utils.match_response(http_res, "200", "application/json"):
            return utils.unmarshal_json(
                http_res.text, models.CreateTransferResponseBody
            )
        if utils.match_response(http_res, "201", "application/json"):
            return utils.unmarshal_json(http_res.text, models.AsyncTransfer)
        if utils.match_response(http_res, "202", "application/json"):
            return utils.unmarshal_json(http_res.text, models.Transfer)
        if utils.match_response(http_res, "400", "application/json"):
            data = utils.unmarshal_json(http_res.text, models.GenericErrorData)
            raise models.GenericError(data=data)
        if utils.match_response(http_res, ["404", "429", "4XX"], "*"):
            http_res_text = utils.stream_to_text(http_res)
            raise models.APIError(
                "API error occurred", http_res.status_code, http_res_text, http_res
            )
        if utils.match_response(http_res, "409", "application/json"):
            data = utils.unmarshal_json(http_res.text, models.TransferErrorData)
            raise models.TransferError(data=data)
        if utils.match_response(http_res, "422", "application/json"):
            data = utils.unmarshal_json(
                http_res.text, models.TransferValidationErrorData
            )
            raise models.TransferValidationError(data=data)
        if utils.match_response(http_res, ["500", "504", "5XX"], "*"):
            http_res_text = utils.stream_to_text(http_res)
            raise models.APIError(
                "API error occurred", http_res.status_code, http_res_text, http_res
            )

        content_type = http_res.headers.get("Content-Type")
        http_res_text = utils.stream_to_text(http_res)
        raise models.APIError(
            f"Unexpected response received (code: {http_res.status_code}, type: {content_type})",
            http_res.status_code,
            http_res_text,
            http_res,
        )

    async def create_transfer_async(
        self,
        *,
        security: Union[
            models.CreateTransferSecurity, models.CreateTransferSecurityTypedDict
        ],
        x_idempotency_key: str,
        account_id: str,
        source: Union[
            models.CreateTransferSource, models.CreateTransferSourceTypedDict
        ],
        destination: Union[
            models.CreateTransferDestination, models.CreateTransferDestinationTypedDict
        ],
        amount: Union[models.Amount, models.AmountTypedDict],
        x_moov_version: Optional[models.Versions] = None,
        x_wait_for: Optional[models.TransferWaitFor] = None,
        facilitator_fee: Optional[
            Union[models.FacilitatorFee, models.FacilitatorFeeTypedDict]
        ] = None,
        description: Optional[str] = None,
        metadata: Optional[Dict[str, str]] = None,
        retries: OptionalNullable[utils.RetryConfig] = UNSET,
        server_url: Optional[str] = None,
        timeout_ms: Optional[int] = None,
        http_headers: Optional[Mapping[str, str]] = None,
    ) -> models.CreateTransferResponse:
        r"""Move money by providing the source, destination, and amount in the request body.

        Read our [transfers overview guide](https://docs.moov.io/guides/money-movement/overview/) to learn more.

        To access this endpoint using a [token](https://docs.moov.io/api/authentication/access-tokens/) you'll need to specify the `/accounts/{accountID}/transfers.write`
        scope.

        :param security:
        :param x_idempotency_key: Prevents duplicate transfers from being created.
        :param account_id: The merchant's Moov account ID.
        :param source: Where funds for a transfer originate. For the source, you must include either a `paymentMethodID` or a `transferID`.
        :param destination: The final stage of a transfer and the ultimate recipient of the funds.
        :param amount:
        :param x_moov_version: Specify an API version.
        :param x_wait_for: Optional header that indicates whether to return a synchronous response that includes full transfer and rail-specific details or an  asynchronous response indicating the transfer was created (this is the default response if the header is omitted).
        :param facilitator_fee: Total or markup fee.
        :param description: An optional description of the transfer for your own internal use.
        :param metadata: Free-form key-value pair list. Useful for storing information that is not captured elsewhere.
        :param retries: Override the default retry configuration for this method
        :param server_url: Override the default server URL for this method
        :param timeout_ms: Override the default request timeout configuration for this method in milliseconds
        :param http_headers: Additional headers to set or replace on requests.
        """
        base_url = None
        url_variables = None
        if timeout_ms is None:
            timeout_ms = self.sdk_configuration.timeout_ms

        if server_url is not None:
            base_url = server_url

        request = models.CreateTransferRequest(
            x_moov_version=x_moov_version,
            x_idempotency_key=x_idempotency_key,
            x_wait_for=x_wait_for,
            account_id=account_id,
            create_transfer=models.CreateTransfer(
                source=utils.get_pydantic_model(source, models.CreateTransferSource),
                destination=utils.get_pydantic_model(
                    destination, models.CreateTransferDestination
                ),
                amount=utils.get_pydantic_model(amount, models.Amount),
                facilitator_fee=utils.get_pydantic_model(
                    facilitator_fee, Optional[models.FacilitatorFee]
                ),
                description=description,
                metadata=metadata,
            ),
        )

        req = self._build_request_async(
            method="POST",
            path="/accounts/{accountID}/transfers",
            base_url=base_url,
            url_variables=url_variables,
            request=request,
            request_body_required=True,
            request_has_path_params=True,
            request_has_query_params=True,
            user_agent_header="user-agent",
            accept_header_value="application/json",
            http_headers=http_headers,
            security=utils.get_pydantic_model(security, models.CreateTransferSecurity),
            get_serialized_body=lambda: utils.serialize_request_body(
                request.create_transfer, False, False, "json", models.CreateTransfer
            ),
            timeout_ms=timeout_ms,
        )

        if retries == UNSET:
            if self.sdk_configuration.retry_config is not UNSET:
                retries = self.sdk_configuration.retry_config

        retry_config = None
        if isinstance(retries, utils.RetryConfig):
            retry_config = (retries, ["429", "500", "502", "503", "504"])

        http_res = await self.do_request_async(
            hook_ctx=HookContext(
                operation_id="createTransfer",
                oauth2_scopes=[],
                security_source=security,
            ),
            request=req,
            error_status_codes=[
                "400",
                "404",
                "409",
                "422",
                "429",
                "4XX",
                "500",
                "504",
                "5XX",
            ],
            retry_config=retry_config,
        )

        data: Any = None
        if utils.match_response(http_res, "200", "application/json"):
            return utils.unmarshal_json(
                http_res.text, models.CreateTransferResponseBody
            )
        if utils.match_response(http_res, "201", "application/json"):
            return utils.unmarshal_json(http_res.text, models.AsyncTransfer)
        if utils.match_response(http_res, "202", "application/json"):
            return utils.unmarshal_json(http_res.text, models.Transfer)
        if utils.match_response(http_res, "400", "application/json"):
            data = utils.unmarshal_json(http_res.text, models.GenericErrorData)
            raise models.GenericError(data=data)
        if utils.match_response(http_res, ["404", "429", "4XX"], "*"):
            http_res_text = await utils.stream_to_text_async(http_res)
            raise models.APIError(
                "API error occurred", http_res.status_code, http_res_text, http_res
            )
        if utils.match_response(http_res, "409", "application/json"):
            data = utils.unmarshal_json(http_res.text, models.TransferErrorData)
            raise models.TransferError(data=data)
        if utils.match_response(http_res, "422", "application/json"):
            data = utils.unmarshal_json(
                http_res.text, models.TransferValidationErrorData
            )
            raise models.TransferValidationError(data=data)
        if utils.match_response(http_res, ["500", "504", "5XX"], "*"):
            http_res_text = await utils.stream_to_text_async(http_res)
            raise models.APIError(
                "API error occurred", http_res.status_code, http_res_text, http_res
            )

        content_type = http_res.headers.get("Content-Type")
        http_res_text = await utils.stream_to_text_async(http_res)
        raise models.APIError(
            f"Unexpected response received (code: {http_res.status_code}, type: {content_type})",
            http_res.status_code,
            http_res_text,
            http_res,
        )

    def list_transfers(
        self,
        *,
        security: Union[
            models.ListTransfersSecurity, models.ListTransfersSecurityTypedDict
        ],
        account_id: str,
        x_moov_version: Optional[models.Versions] = None,
        account_i_ds: Optional[List[str]] = None,
        status: Optional[models.TransferStatus] = None,
        start_date_time: Optional[datetime] = None,
        end_date_time: Optional[datetime] = None,
        group_id: Optional[str] = None,
        refunded: Optional[bool] = None,
        disputed: Optional[bool] = None,
        skip: Optional[int] = None,
        count: Optional[int] = None,
        retries: OptionalNullable[utils.RetryConfig] = UNSET,
        server_url: Optional[str] = None,
        timeout_ms: Optional[int] = None,
        http_headers: Optional[Mapping[str, str]] = None,
    ) -> List[models.Transfer]:
        r"""List all the transfers associated with a particular Moov account.

        Read our [transfers overview guide](https://docs.moov.io/guides/money-movement/overview/) to learn more.

        When you run this request, you retrieve 200 transfers at a time. You can advance past a results set of 200 transfers by using the `skip` parameter (for example,
        if you set `skip`= 10, you will see a results set of 200 transfers after the first 2000). If you are searching a high volume of transfers, the request will likely
        process very slowly. To achieve faster performance, restrict the data as much as you can by using the `StartDateTime` and `EndDateTime` parameters for a limited
        period of time. You can run multiple requests in smaller time window increments until you've retrieved all the transfers you need.

        To access this endpoint using a [token](https://docs.moov.io/api/authentication/access-tokens/) you'll need to specify the `/accounts/{accountID}/transfers.read`
        scope.

        :param security:
        :param account_id:
        :param x_moov_version: Specify an API version.
        :param account_i_ds: Optional, comma-separated account IDs by which the response is filtered based on whether the account ID is the source or destination.
        :param status: Optional parameter for filtering transfers by status.
        :param start_date_time: Optional date-time which inclusively filters all transfers created after this date-time.
        :param end_date_time: Optional date-time which exclusively filters all transfers created before this date-time.
        :param group_id: Optional ID to filter for transfers in the same group.
        :param refunded: Optional parameter to only return refunded transfers.
        :param disputed: Optional parameter to only return disputed transfers.
        :param skip:
        :param count:
        :param retries: Override the default retry configuration for this method
        :param server_url: Override the default server URL for this method
        :param timeout_ms: Override the default request timeout configuration for this method in milliseconds
        :param http_headers: Additional headers to set or replace on requests.
        """
        base_url = None
        url_variables = None
        if timeout_ms is None:
            timeout_ms = self.sdk_configuration.timeout_ms

        if server_url is not None:
            base_url = server_url

        request = models.ListTransfersRequest(
            x_moov_version=x_moov_version,
            account_i_ds=account_i_ds,
            status=status,
            start_date_time=start_date_time,
            end_date_time=end_date_time,
            group_id=group_id,
            refunded=refunded,
            disputed=disputed,
            skip=skip,
            count=count,
            account_id=account_id,
        )

        req = self._build_request(
            method="GET",
            path="/accounts/{accountID}/transfers",
            base_url=base_url,
            url_variables=url_variables,
            request=request,
            request_body_required=False,
            request_has_path_params=True,
            request_has_query_params=True,
            user_agent_header="user-agent",
            accept_header_value="application/json",
            http_headers=http_headers,
            security=utils.get_pydantic_model(security, models.ListTransfersSecurity),
            timeout_ms=timeout_ms,
        )

        if retries == UNSET:
            if self.sdk_configuration.retry_config is not UNSET:
                retries = self.sdk_configuration.retry_config

        retry_config = None
        if isinstance(retries, utils.RetryConfig):
            retry_config = (retries, ["429", "500", "502", "503", "504"])

        http_res = self.do_request(
            hook_ctx=HookContext(
                operation_id="listTransfers", oauth2_scopes=[], security_source=security
            ),
            request=req,
            error_status_codes=["401", "403", "429", "4XX", "500", "504", "5XX"],
            retry_config=retry_config,
        )

        if utils.match_response(http_res, "200", "application/json"):
            return utils.unmarshal_json(http_res.text, List[models.Transfer])
        if utils.match_response(http_res, ["401", "403", "429", "4XX"], "*"):
            http_res_text = utils.stream_to_text(http_res)
            raise models.APIError(
                "API error occurred", http_res.status_code, http_res_text, http_res
            )
        if utils.match_response(http_res, ["500", "504", "5XX"], "*"):
            http_res_text = utils.stream_to_text(http_res)
            raise models.APIError(
                "API error occurred", http_res.status_code, http_res_text, http_res
            )

        content_type = http_res.headers.get("Content-Type")
        http_res_text = utils.stream_to_text(http_res)
        raise models.APIError(
            f"Unexpected response received (code: {http_res.status_code}, type: {content_type})",
            http_res.status_code,
            http_res_text,
            http_res,
        )

    async def list_transfers_async(
        self,
        *,
        security: Union[
            models.ListTransfersSecurity, models.ListTransfersSecurityTypedDict
        ],
        account_id: str,
        x_moov_version: Optional[models.Versions] = None,
        account_i_ds: Optional[List[str]] = None,
        status: Optional[models.TransferStatus] = None,
        start_date_time: Optional[datetime] = None,
        end_date_time: Optional[datetime] = None,
        group_id: Optional[str] = None,
        refunded: Optional[bool] = None,
        disputed: Optional[bool] = None,
        skip: Optional[int] = None,
        count: Optional[int] = None,
        retries: OptionalNullable[utils.RetryConfig] = UNSET,
        server_url: Optional[str] = None,
        timeout_ms: Optional[int] = None,
        http_headers: Optional[Mapping[str, str]] = None,
    ) -> List[models.Transfer]:
        r"""List all the transfers associated with a particular Moov account.

        Read our [transfers overview guide](https://docs.moov.io/guides/money-movement/overview/) to learn more.

        When you run this request, you retrieve 200 transfers at a time. You can advance past a results set of 200 transfers by using the `skip` parameter (for example,
        if you set `skip`= 10, you will see a results set of 200 transfers after the first 2000). If you are searching a high volume of transfers, the request will likely
        process very slowly. To achieve faster performance, restrict the data as much as you can by using the `StartDateTime` and `EndDateTime` parameters for a limited
        period of time. You can run multiple requests in smaller time window increments until you've retrieved all the transfers you need.

        To access this endpoint using a [token](https://docs.moov.io/api/authentication/access-tokens/) you'll need to specify the `/accounts/{accountID}/transfers.read`
        scope.

        :param security:
        :param account_id:
        :param x_moov_version: Specify an API version.
        :param account_i_ds: Optional, comma-separated account IDs by which the response is filtered based on whether the account ID is the source or destination.
        :param status: Optional parameter for filtering transfers by status.
        :param start_date_time: Optional date-time which inclusively filters all transfers created after this date-time.
        :param end_date_time: Optional date-time which exclusively filters all transfers created before this date-time.
        :param group_id: Optional ID to filter for transfers in the same group.
        :param refunded: Optional parameter to only return refunded transfers.
        :param disputed: Optional parameter to only return disputed transfers.
        :param skip:
        :param count:
        :param retries: Override the default retry configuration for this method
        :param server_url: Override the default server URL for this method
        :param timeout_ms: Override the default request timeout configuration for this method in milliseconds
        :param http_headers: Additional headers to set or replace on requests.
        """
        base_url = None
        url_variables = None
        if timeout_ms is None:
            timeout_ms = self.sdk_configuration.timeout_ms

        if server_url is not None:
            base_url = server_url

        request = models.ListTransfersRequest(
            x_moov_version=x_moov_version,
            account_i_ds=account_i_ds,
            status=status,
            start_date_time=start_date_time,
            end_date_time=end_date_time,
            group_id=group_id,
            refunded=refunded,
            disputed=disputed,
            skip=skip,
            count=count,
            account_id=account_id,
        )

        req = self._build_request_async(
            method="GET",
            path="/accounts/{accountID}/transfers",
            base_url=base_url,
            url_variables=url_variables,
            request=request,
            request_body_required=False,
            request_has_path_params=True,
            request_has_query_params=True,
            user_agent_header="user-agent",
            accept_header_value="application/json",
            http_headers=http_headers,
            security=utils.get_pydantic_model(security, models.ListTransfersSecurity),
            timeout_ms=timeout_ms,
        )

        if retries == UNSET:
            if self.sdk_configuration.retry_config is not UNSET:
                retries = self.sdk_configuration.retry_config

        retry_config = None
        if isinstance(retries, utils.RetryConfig):
            retry_config = (retries, ["429", "500", "502", "503", "504"])

        http_res = await self.do_request_async(
            hook_ctx=HookContext(
                operation_id="listTransfers", oauth2_scopes=[], security_source=security
            ),
            request=req,
            error_status_codes=["401", "403", "429", "4XX", "500", "504", "5XX"],
            retry_config=retry_config,
        )

        if utils.match_response(http_res, "200", "application/json"):
            return utils.unmarshal_json(http_res.text, List[models.Transfer])
        if utils.match_response(http_res, ["401", "403", "429", "4XX"], "*"):
            http_res_text = await utils.stream_to_text_async(http_res)
            raise models.APIError(
                "API error occurred", http_res.status_code, http_res_text, http_res
            )
        if utils.match_response(http_res, ["500", "504", "5XX"], "*"):
            http_res_text = await utils.stream_to_text_async(http_res)
            raise models.APIError(
                "API error occurred", http_res.status_code, http_res_text, http_res
            )

        content_type = http_res.headers.get("Content-Type")
        http_res_text = await utils.stream_to_text_async(http_res)
        raise models.APIError(
            f"Unexpected response received (code: {http_res.status_code}, type: {content_type})",
            http_res.status_code,
            http_res_text,
            http_res,
        )

    def get_transfer(
        self,
        *,
        security: Union[
            models.GetTransferSecurity, models.GetTransferSecurityTypedDict
        ],
        transfer_id: str,
        account_id: str,
        x_moov_version: Optional[models.Versions] = None,
        retries: OptionalNullable[utils.RetryConfig] = UNSET,
        server_url: Optional[str] = None,
        timeout_ms: Optional[int] = None,
        http_headers: Optional[Mapping[str, str]] = None,
    ) -> models.Transfer:
        r"""Retrieve full transfer details for an individual transfer of a particular Moov account.

        Payment rail-specific details are included in the source and destination. Read our [transfers overview guide](https://docs.moov.io/guides/money-movement/overview/)
        to learn more.

        To access this endpoint using a [token](https://docs.moov.io/api/authentication/access-tokens/) you'll need to specify the `/accounts/{accountID}/transfers.read`
        scope.

        :param security:
        :param transfer_id: Identifier for the transfer.
        :param account_id:
        :param x_moov_version: Specify an API version.
        :param retries: Override the default retry configuration for this method
        :param server_url: Override the default server URL for this method
        :param timeout_ms: Override the default request timeout configuration for this method in milliseconds
        :param http_headers: Additional headers to set or replace on requests.
        """
        base_url = None
        url_variables = None
        if timeout_ms is None:
            timeout_ms = self.sdk_configuration.timeout_ms

        if server_url is not None:
            base_url = server_url

        request = models.GetTransferRequest(
            x_moov_version=x_moov_version,
            transfer_id=transfer_id,
            account_id=account_id,
        )

        req = self._build_request(
            method="GET",
            path="/accounts/{accountID}/transfers/{transferID}",
            base_url=base_url,
            url_variables=url_variables,
            request=request,
            request_body_required=False,
            request_has_path_params=True,
            request_has_query_params=True,
            user_agent_header="user-agent",
            accept_header_value="application/json",
            http_headers=http_headers,
            security=utils.get_pydantic_model(security, models.GetTransferSecurity),
            timeout_ms=timeout_ms,
        )

        if retries == UNSET:
            if self.sdk_configuration.retry_config is not UNSET:
                retries = self.sdk_configuration.retry_config

        retry_config = None
        if isinstance(retries, utils.RetryConfig):
            retry_config = (retries, ["429", "500", "502", "503", "504"])

        http_res = self.do_request(
            hook_ctx=HookContext(
                operation_id="getTransfer", oauth2_scopes=[], security_source=security
            ),
            request=req,
            error_status_codes=["401", "403", "404", "429", "4XX", "500", "504", "5XX"],
            retry_config=retry_config,
        )

        if utils.match_response(http_res, "200", "application/json"):
            return utils.unmarshal_json(http_res.text, models.Transfer)
        if utils.match_response(http_res, ["401", "403", "404", "429", "4XX"], "*"):
            http_res_text = utils.stream_to_text(http_res)
            raise models.APIError(
                "API error occurred", http_res.status_code, http_res_text, http_res
            )
        if utils.match_response(http_res, ["500", "504", "5XX"], "*"):
            http_res_text = utils.stream_to_text(http_res)
            raise models.APIError(
                "API error occurred", http_res.status_code, http_res_text, http_res
            )

        content_type = http_res.headers.get("Content-Type")
        http_res_text = utils.stream_to_text(http_res)
        raise models.APIError(
            f"Unexpected response received (code: {http_res.status_code}, type: {content_type})",
            http_res.status_code,
            http_res_text,
            http_res,
        )

    async def get_transfer_async(
        self,
        *,
        security: Union[
            models.GetTransferSecurity, models.GetTransferSecurityTypedDict
        ],
        transfer_id: str,
        account_id: str,
        x_moov_version: Optional[models.Versions] = None,
        retries: OptionalNullable[utils.RetryConfig] = UNSET,
        server_url: Optional[str] = None,
        timeout_ms: Optional[int] = None,
        http_headers: Optional[Mapping[str, str]] = None,
    ) -> models.Transfer:
        r"""Retrieve full transfer details for an individual transfer of a particular Moov account.

        Payment rail-specific details are included in the source and destination. Read our [transfers overview guide](https://docs.moov.io/guides/money-movement/overview/)
        to learn more.

        To access this endpoint using a [token](https://docs.moov.io/api/authentication/access-tokens/) you'll need to specify the `/accounts/{accountID}/transfers.read`
        scope.

        :param security:
        :param transfer_id: Identifier for the transfer.
        :param account_id:
        :param x_moov_version: Specify an API version.
        :param retries: Override the default retry configuration for this method
        :param server_url: Override the default server URL for this method
        :param timeout_ms: Override the default request timeout configuration for this method in milliseconds
        :param http_headers: Additional headers to set or replace on requests.
        """
        base_url = None
        url_variables = None
        if timeout_ms is None:
            timeout_ms = self.sdk_configuration.timeout_ms

        if server_url is not None:
            base_url = server_url

        request = models.GetTransferRequest(
            x_moov_version=x_moov_version,
            transfer_id=transfer_id,
            account_id=account_id,
        )

        req = self._build_request_async(
            method="GET",
            path="/accounts/{accountID}/transfers/{transferID}",
            base_url=base_url,
            url_variables=url_variables,
            request=request,
            request_body_required=False,
            request_has_path_params=True,
            request_has_query_params=True,
            user_agent_header="user-agent",
            accept_header_value="application/json",
            http_headers=http_headers,
            security=utils.get_pydantic_model(security, models.GetTransferSecurity),
            timeout_ms=timeout_ms,
        )

        if retries == UNSET:
            if self.sdk_configuration.retry_config is not UNSET:
                retries = self.sdk_configuration.retry_config

        retry_config = None
        if isinstance(retries, utils.RetryConfig):
            retry_config = (retries, ["429", "500", "502", "503", "504"])

        http_res = await self.do_request_async(
            hook_ctx=HookContext(
                operation_id="getTransfer", oauth2_scopes=[], security_source=security
            ),
            request=req,
            error_status_codes=["401", "403", "404", "429", "4XX", "500", "504", "5XX"],
            retry_config=retry_config,
        )

        if utils.match_response(http_res, "200", "application/json"):
            return utils.unmarshal_json(http_res.text, models.Transfer)
        if utils.match_response(http_res, ["401", "403", "404", "429", "4XX"], "*"):
            http_res_text = await utils.stream_to_text_async(http_res)
            raise models.APIError(
                "API error occurred", http_res.status_code, http_res_text, http_res
            )
        if utils.match_response(http_res, ["500", "504", "5XX"], "*"):
            http_res_text = await utils.stream_to_text_async(http_res)
            raise models.APIError(
                "API error occurred", http_res.status_code, http_res_text, http_res
            )

        content_type = http_res.headers.get("Content-Type")
        http_res_text = await utils.stream_to_text_async(http_res)
        raise models.APIError(
            f"Unexpected response received (code: {http_res.status_code}, type: {content_type})",
            http_res.status_code,
            http_res_text,
            http_res,
        )

    def patch_transfer(
        self,
        *,
        security: Union[
            models.PatchTransferSecurity, models.PatchTransferSecurityTypedDict
        ],
        transfer_id: str,
        account_id: str,
        x_moov_version: Optional[models.Versions] = None,
        retries: OptionalNullable[utils.RetryConfig] = UNSET,
        server_url: Optional[str] = None,
        timeout_ms: Optional[int] = None,
        http_headers: Optional[Mapping[str, str]] = None,
    ) -> models.Transfer:
        r"""Update the metadata contained on a transfer.

        Read our [transfers overview guide](https://docs.moov.io/guides/money-movement/overview/) to learn more.

        To access this endpoint using a [token](https://docs.moov.io/api/authentication/access-tokens/) you'll need to specify the `/accounts/{accountID}/transfers.write`
        scope.

        :param security:
        :param transfer_id: Identifier for the transfer.
        :param account_id:
        :param x_moov_version: Specify an API version.
        :param retries: Override the default retry configuration for this method
        :param server_url: Override the default server URL for this method
        :param timeout_ms: Override the default request timeout configuration for this method in milliseconds
        :param http_headers: Additional headers to set or replace on requests.
        """
        base_url = None
        url_variables = None
        if timeout_ms is None:
            timeout_ms = self.sdk_configuration.timeout_ms

        if server_url is not None:
            base_url = server_url

        request = models.PatchTransferRequest(
            x_moov_version=x_moov_version,
            transfer_id=transfer_id,
            account_id=account_id,
        )

        req = self._build_request(
            method="PATCH",
            path="/accounts/{accountID}/transfers/{transferID}",
            base_url=base_url,
            url_variables=url_variables,
            request=request,
            request_body_required=False,
            request_has_path_params=True,
            request_has_query_params=True,
            user_agent_header="user-agent",
            accept_header_value="application/json",
            http_headers=http_headers,
            security=utils.get_pydantic_model(security, models.PatchTransferSecurity),
            timeout_ms=timeout_ms,
        )

        if retries == UNSET:
            if self.sdk_configuration.retry_config is not UNSET:
                retries = self.sdk_configuration.retry_config

        retry_config = None
        if isinstance(retries, utils.RetryConfig):
            retry_config = (retries, ["429", "500", "502", "503", "504"])

        http_res = self.do_request(
            hook_ctx=HookContext(
                operation_id="patchTransfer", oauth2_scopes=[], security_source=security
            ),
            request=req,
            error_status_codes=["401", "403", "404", "429", "4XX", "500", "504", "5XX"],
            retry_config=retry_config,
        )

        if utils.match_response(http_res, "200", "application/json"):
            return utils.unmarshal_json(http_res.text, models.Transfer)
        if utils.match_response(http_res, ["401", "403", "404", "429", "4XX"], "*"):
            http_res_text = utils.stream_to_text(http_res)
            raise models.APIError(
                "API error occurred", http_res.status_code, http_res_text, http_res
            )
        if utils.match_response(http_res, ["500", "504", "5XX"], "*"):
            http_res_text = utils.stream_to_text(http_res)
            raise models.APIError(
                "API error occurred", http_res.status_code, http_res_text, http_res
            )

        content_type = http_res.headers.get("Content-Type")
        http_res_text = utils.stream_to_text(http_res)
        raise models.APIError(
            f"Unexpected response received (code: {http_res.status_code}, type: {content_type})",
            http_res.status_code,
            http_res_text,
            http_res,
        )

    async def patch_transfer_async(
        self,
        *,
        security: Union[
            models.PatchTransferSecurity, models.PatchTransferSecurityTypedDict
        ],
        transfer_id: str,
        account_id: str,
        x_moov_version: Optional[models.Versions] = None,
        retries: OptionalNullable[utils.RetryConfig] = UNSET,
        server_url: Optional[str] = None,
        timeout_ms: Optional[int] = None,
        http_headers: Optional[Mapping[str, str]] = None,
    ) -> models.Transfer:
        r"""Update the metadata contained on a transfer.

        Read our [transfers overview guide](https://docs.moov.io/guides/money-movement/overview/) to learn more.

        To access this endpoint using a [token](https://docs.moov.io/api/authentication/access-tokens/) you'll need to specify the `/accounts/{accountID}/transfers.write`
        scope.

        :param security:
        :param transfer_id: Identifier for the transfer.
        :param account_id:
        :param x_moov_version: Specify an API version.
        :param retries: Override the default retry configuration for this method
        :param server_url: Override the default server URL for this method
        :param timeout_ms: Override the default request timeout configuration for this method in milliseconds
        :param http_headers: Additional headers to set or replace on requests.
        """
        base_url = None
        url_variables = None
        if timeout_ms is None:
            timeout_ms = self.sdk_configuration.timeout_ms

        if server_url is not None:
            base_url = server_url

        request = models.PatchTransferRequest(
            x_moov_version=x_moov_version,
            transfer_id=transfer_id,
            account_id=account_id,
        )

        req = self._build_request_async(
            method="PATCH",
            path="/accounts/{accountID}/transfers/{transferID}",
            base_url=base_url,
            url_variables=url_variables,
            request=request,
            request_body_required=False,
            request_has_path_params=True,
            request_has_query_params=True,
            user_agent_header="user-agent",
            accept_header_value="application/json",
            http_headers=http_headers,
            security=utils.get_pydantic_model(security, models.PatchTransferSecurity),
            timeout_ms=timeout_ms,
        )

        if retries == UNSET:
            if self.sdk_configuration.retry_config is not UNSET:
                retries = self.sdk_configuration.retry_config

        retry_config = None
        if isinstance(retries, utils.RetryConfig):
            retry_config = (retries, ["429", "500", "502", "503", "504"])

        http_res = await self.do_request_async(
            hook_ctx=HookContext(
                operation_id="patchTransfer", oauth2_scopes=[], security_source=security
            ),
            request=req,
            error_status_codes=["401", "403", "404", "429", "4XX", "500", "504", "5XX"],
            retry_config=retry_config,
        )

        if utils.match_response(http_res, "200", "application/json"):
            return utils.unmarshal_json(http_res.text, models.Transfer)
        if utils.match_response(http_res, ["401", "403", "404", "429", "4XX"], "*"):
            http_res_text = await utils.stream_to_text_async(http_res)
            raise models.APIError(
                "API error occurred", http_res.status_code, http_res_text, http_res
            )
        if utils.match_response(http_res, ["500", "504", "5XX"], "*"):
            http_res_text = await utils.stream_to_text_async(http_res)
            raise models.APIError(
                "API error occurred", http_res.status_code, http_res_text, http_res
            )

        content_type = http_res.headers.get("Content-Type")
        http_res_text = await utils.stream_to_text_async(http_res)
        raise models.APIError(
            f"Unexpected response received (code: {http_res.status_code}, type: {content_type})",
            http_res.status_code,
            http_res_text,
            http_res,
        )

    def refund_transfer(
        self,
        *,
        security: Union[
            models.RefundTransferSecurity, models.RefundTransferSecurityTypedDict
        ],
        x_idempotency_key: str,
        account_id: str,
        transfer_id: str,
        x_moov_version: Optional[models.Versions] = None,
        x_wait_for: Optional[models.TransferWaitFor] = None,
        amount: Optional[int] = None,
        retries: OptionalNullable[utils.RetryConfig] = UNSET,
        server_url: Optional[str] = None,
        timeout_ms: Optional[int] = None,
        http_headers: Optional[Mapping[str, str]] = None,
    ) -> models.RefundTransferResponse:
        r"""Initiate a refund for a card transfer.

        **Use the [Cancel or refund a card transfer](https://docs.moov.io/api/money-movement/refunds/cancel/) endpoint for more comprehensive cancel and refund options.**
        See the [reversals](https://docs.moov.io/guides/money-movement/accept-payments/card-acceptance/reversals/) guide for more information.

        To access this endpoint using a [token](https://docs.moov.io/api/authentication/access-tokens/) you'll need to specify the `/accounts/{accountID}/transfers.write`
        scope.

        :param security:
        :param x_idempotency_key: Prevents duplicate refunds from being created.
        :param account_id: The merchant's Moov account ID.
        :param transfer_id: Identifier for the transfer.
        :param x_moov_version: Specify an API version.
        :param x_wait_for: Optional header that indicates whether to return a synchronous response that includes full transfer and rail-specific details or an  asynchronous response indicating the transfer was created (this is the default response if the header is omitted).
        :param amount: Amount to refund in cents. If null, the original transfer's full amount will be refunded.
        :param retries: Override the default retry configuration for this method
        :param server_url: Override the default server URL for this method
        :param timeout_ms: Override the default request timeout configuration for this method in milliseconds
        :param http_headers: Additional headers to set or replace on requests.
        """
        base_url = None
        url_variables = None
        if timeout_ms is None:
            timeout_ms = self.sdk_configuration.timeout_ms

        if server_url is not None:
            base_url = server_url

        request = models.RefundTransferRequest(
            x_moov_version=x_moov_version,
            x_idempotency_key=x_idempotency_key,
            x_wait_for=x_wait_for,
            account_id=account_id,
            transfer_id=transfer_id,
            create_refund=models.CreateRefund(
                amount=amount,
            ),
        )

        req = self._build_request(
            method="POST",
            path="/accounts/{accountID}/transfers/{transferID}/refunds",
            base_url=base_url,
            url_variables=url_variables,
            request=request,
            request_body_required=False,
            request_has_path_params=True,
            request_has_query_params=True,
            user_agent_header="user-agent",
            accept_header_value="application/json",
            http_headers=http_headers,
            security=utils.get_pydantic_model(security, models.RefundTransferSecurity),
            get_serialized_body=lambda: utils.serialize_request_body(
                request.create_refund,
                False,
                True,
                "json",
                Optional[models.CreateRefund],
            ),
            timeout_ms=timeout_ms,
        )

        if retries == UNSET:
            if self.sdk_configuration.retry_config is not UNSET:
                retries = self.sdk_configuration.retry_config

        retry_config = None
        if isinstance(retries, utils.RetryConfig):
            retry_config = (retries, ["429", "500", "502", "503", "504"])

        http_res = self.do_request(
            hook_ctx=HookContext(
                operation_id="refundTransfer",
                oauth2_scopes=[],
                security_source=security,
            ),
            request=req,
            error_status_codes=[
                "400",
                "404",
                "409",
                "422",
                "429",
                "4XX",
                "500",
                "504",
                "5XX",
            ],
            retry_config=retry_config,
        )

        data: Any = None
        if utils.match_response(http_res, "200", "application/json"):
            return utils.unmarshal_json(http_res.text, models.CreateRefundResponse)
        if utils.match_response(http_res, "202", "application/json"):
            return utils.unmarshal_json(http_res.text, models.CardAcquiringRefund)
        if utils.match_response(http_res, "400", "application/json"):
            data = utils.unmarshal_json(http_res.text, models.GenericErrorData)
            raise models.GenericError(data=data)
        if utils.match_response(http_res, ["404", "429", "4XX"], "*"):
            http_res_text = utils.stream_to_text(http_res)
            raise models.APIError(
                "API error occurred", http_res.status_code, http_res_text, http_res
            )
        if utils.match_response(http_res, "409", "application/json"):
            data = utils.unmarshal_json(
                http_res.text, models.CardAcquiringRefundErrorData
            )
            raise models.CardAcquiringRefundError(data=data)
        if utils.match_response(http_res, "422", "application/json"):
            data = utils.unmarshal_json(http_res.text, models.RefundValidationErrorData)
            raise models.RefundValidationError(data=data)
        if utils.match_response(http_res, ["500", "504", "5XX"], "*"):
            http_res_text = utils.stream_to_text(http_res)
            raise models.APIError(
                "API error occurred", http_res.status_code, http_res_text, http_res
            )

        content_type = http_res.headers.get("Content-Type")
        http_res_text = utils.stream_to_text(http_res)
        raise models.APIError(
            f"Unexpected response received (code: {http_res.status_code}, type: {content_type})",
            http_res.status_code,
            http_res_text,
            http_res,
        )

    async def refund_transfer_async(
        self,
        *,
        security: Union[
            models.RefundTransferSecurity, models.RefundTransferSecurityTypedDict
        ],
        x_idempotency_key: str,
        account_id: str,
        transfer_id: str,
        x_moov_version: Optional[models.Versions] = None,
        x_wait_for: Optional[models.TransferWaitFor] = None,
        amount: Optional[int] = None,
        retries: OptionalNullable[utils.RetryConfig] = UNSET,
        server_url: Optional[str] = None,
        timeout_ms: Optional[int] = None,
        http_headers: Optional[Mapping[str, str]] = None,
    ) -> models.RefundTransferResponse:
        r"""Initiate a refund for a card transfer.

        **Use the [Cancel or refund a card transfer](https://docs.moov.io/api/money-movement/refunds/cancel/) endpoint for more comprehensive cancel and refund options.**
        See the [reversals](https://docs.moov.io/guides/money-movement/accept-payments/card-acceptance/reversals/) guide for more information.

        To access this endpoint using a [token](https://docs.moov.io/api/authentication/access-tokens/) you'll need to specify the `/accounts/{accountID}/transfers.write`
        scope.

        :param security:
        :param x_idempotency_key: Prevents duplicate refunds from being created.
        :param account_id: The merchant's Moov account ID.
        :param transfer_id: Identifier for the transfer.
        :param x_moov_version: Specify an API version.
        :param x_wait_for: Optional header that indicates whether to return a synchronous response that includes full transfer and rail-specific details or an  asynchronous response indicating the transfer was created (this is the default response if the header is omitted).
        :param amount: Amount to refund in cents. If null, the original transfer's full amount will be refunded.
        :param retries: Override the default retry configuration for this method
        :param server_url: Override the default server URL for this method
        :param timeout_ms: Override the default request timeout configuration for this method in milliseconds
        :param http_headers: Additional headers to set or replace on requests.
        """
        base_url = None
        url_variables = None
        if timeout_ms is None:
            timeout_ms = self.sdk_configuration.timeout_ms

        if server_url is not None:
            base_url = server_url

        request = models.RefundTransferRequest(
            x_moov_version=x_moov_version,
            x_idempotency_key=x_idempotency_key,
            x_wait_for=x_wait_for,
            account_id=account_id,
            transfer_id=transfer_id,
            create_refund=models.CreateRefund(
                amount=amount,
            ),
        )

        req = self._build_request_async(
            method="POST",
            path="/accounts/{accountID}/transfers/{transferID}/refunds",
            base_url=base_url,
            url_variables=url_variables,
            request=request,
            request_body_required=False,
            request_has_path_params=True,
            request_has_query_params=True,
            user_agent_header="user-agent",
            accept_header_value="application/json",
            http_headers=http_headers,
            security=utils.get_pydantic_model(security, models.RefundTransferSecurity),
            get_serialized_body=lambda: utils.serialize_request_body(
                request.create_refund,
                False,
                True,
                "json",
                Optional[models.CreateRefund],
            ),
            timeout_ms=timeout_ms,
        )

        if retries == UNSET:
            if self.sdk_configuration.retry_config is not UNSET:
                retries = self.sdk_configuration.retry_config

        retry_config = None
        if isinstance(retries, utils.RetryConfig):
            retry_config = (retries, ["429", "500", "502", "503", "504"])

        http_res = await self.do_request_async(
            hook_ctx=HookContext(
                operation_id="refundTransfer",
                oauth2_scopes=[],
                security_source=security,
            ),
            request=req,
            error_status_codes=[
                "400",
                "404",
                "409",
                "422",
                "429",
                "4XX",
                "500",
                "504",
                "5XX",
            ],
            retry_config=retry_config,
        )

        data: Any = None
        if utils.match_response(http_res, "200", "application/json"):
            return utils.unmarshal_json(http_res.text, models.CreateRefundResponse)
        if utils.match_response(http_res, "202", "application/json"):
            return utils.unmarshal_json(http_res.text, models.CardAcquiringRefund)
        if utils.match_response(http_res, "400", "application/json"):
            data = utils.unmarshal_json(http_res.text, models.GenericErrorData)
            raise models.GenericError(data=data)
        if utils.match_response(http_res, ["404", "429", "4XX"], "*"):
            http_res_text = await utils.stream_to_text_async(http_res)
            raise models.APIError(
                "API error occurred", http_res.status_code, http_res_text, http_res
            )
        if utils.match_response(http_res, "409", "application/json"):
            data = utils.unmarshal_json(
                http_res.text, models.CardAcquiringRefundErrorData
            )
            raise models.CardAcquiringRefundError(data=data)
        if utils.match_response(http_res, "422", "application/json"):
            data = utils.unmarshal_json(http_res.text, models.RefundValidationErrorData)
            raise models.RefundValidationError(data=data)
        if utils.match_response(http_res, ["500", "504", "5XX"], "*"):
            http_res_text = await utils.stream_to_text_async(http_res)
            raise models.APIError(
                "API error occurred", http_res.status_code, http_res_text, http_res
            )

        content_type = http_res.headers.get("Content-Type")
        http_res_text = await utils.stream_to_text_async(http_res)
        raise models.APIError(
            f"Unexpected response received (code: {http_res.status_code}, type: {content_type})",
            http_res.status_code,
            http_res_text,
            http_res,
        )

    def list_refunds(
        self,
        *,
        security: Union[
            models.ListRefundsSecurity, models.ListRefundsSecurityTypedDict
        ],
        account_id: str,
        transfer_id: str,
        x_moov_version: Optional[models.Versions] = None,
        retries: OptionalNullable[utils.RetryConfig] = UNSET,
        server_url: Optional[str] = None,
        timeout_ms: Optional[int] = None,
        http_headers: Optional[Mapping[str, str]] = None,
    ) -> List[models.CardAcquiringRefund]:
        r"""Get a list of refunds for a card transfer.

        To access this endpoint using a [token](https://docs.moov.io/api/authentication/access-tokens/) you'll need to specify the `/accounts/{accountID}/transfers.read`
        scope.

        :param security:
        :param account_id:
        :param transfer_id: Identifier for the transfer.
        :param x_moov_version: Specify an API version.
        :param retries: Override the default retry configuration for this method
        :param server_url: Override the default server URL for this method
        :param timeout_ms: Override the default request timeout configuration for this method in milliseconds
        :param http_headers: Additional headers to set or replace on requests.
        """
        base_url = None
        url_variables = None
        if timeout_ms is None:
            timeout_ms = self.sdk_configuration.timeout_ms

        if server_url is not None:
            base_url = server_url

        request = models.ListRefundsRequest(
            x_moov_version=x_moov_version,
            account_id=account_id,
            transfer_id=transfer_id,
        )

        req = self._build_request(
            method="GET",
            path="/accounts/{accountID}/transfers/{transferID}/refunds",
            base_url=base_url,
            url_variables=url_variables,
            request=request,
            request_body_required=False,
            request_has_path_params=True,
            request_has_query_params=True,
            user_agent_header="user-agent",
            accept_header_value="application/json",
            http_headers=http_headers,
            security=utils.get_pydantic_model(security, models.ListRefundsSecurity),
            timeout_ms=timeout_ms,
        )

        if retries == UNSET:
            if self.sdk_configuration.retry_config is not UNSET:
                retries = self.sdk_configuration.retry_config

        retry_config = None
        if isinstance(retries, utils.RetryConfig):
            retry_config = (retries, ["429", "500", "502", "503", "504"])

        http_res = self.do_request(
            hook_ctx=HookContext(
                operation_id="listRefunds", oauth2_scopes=[], security_source=security
            ),
            request=req,
            error_status_codes=["401", "403", "429", "4XX", "500", "504", "5XX"],
            retry_config=retry_config,
        )

        if utils.match_response(http_res, "200", "application/json"):
            return utils.unmarshal_json(http_res.text, List[models.CardAcquiringRefund])
        if utils.match_response(http_res, ["401", "403", "429", "4XX"], "*"):
            http_res_text = utils.stream_to_text(http_res)
            raise models.APIError(
                "API error occurred", http_res.status_code, http_res_text, http_res
            )
        if utils.match_response(http_res, ["500", "504", "5XX"], "*"):
            http_res_text = utils.stream_to_text(http_res)
            raise models.APIError(
                "API error occurred", http_res.status_code, http_res_text, http_res
            )

        content_type = http_res.headers.get("Content-Type")
        http_res_text = utils.stream_to_text(http_res)
        raise models.APIError(
            f"Unexpected response received (code: {http_res.status_code}, type: {content_type})",
            http_res.status_code,
            http_res_text,
            http_res,
        )

    async def list_refunds_async(
        self,
        *,
        security: Union[
            models.ListRefundsSecurity, models.ListRefundsSecurityTypedDict
        ],
        account_id: str,
        transfer_id: str,
        x_moov_version: Optional[models.Versions] = None,
        retries: OptionalNullable[utils.RetryConfig] = UNSET,
        server_url: Optional[str] = None,
        timeout_ms: Optional[int] = None,
        http_headers: Optional[Mapping[str, str]] = None,
    ) -> List[models.CardAcquiringRefund]:
        r"""Get a list of refunds for a card transfer.

        To access this endpoint using a [token](https://docs.moov.io/api/authentication/access-tokens/) you'll need to specify the `/accounts/{accountID}/transfers.read`
        scope.

        :param security:
        :param account_id:
        :param transfer_id: Identifier for the transfer.
        :param x_moov_version: Specify an API version.
        :param retries: Override the default retry configuration for this method
        :param server_url: Override the default server URL for this method
        :param timeout_ms: Override the default request timeout configuration for this method in milliseconds
        :param http_headers: Additional headers to set or replace on requests.
        """
        base_url = None
        url_variables = None
        if timeout_ms is None:
            timeout_ms = self.sdk_configuration.timeout_ms

        if server_url is not None:
            base_url = server_url

        request = models.ListRefundsRequest(
            x_moov_version=x_moov_version,
            account_id=account_id,
            transfer_id=transfer_id,
        )

        req = self._build_request_async(
            method="GET",
            path="/accounts/{accountID}/transfers/{transferID}/refunds",
            base_url=base_url,
            url_variables=url_variables,
            request=request,
            request_body_required=False,
            request_has_path_params=True,
            request_has_query_params=True,
            user_agent_header="user-agent",
            accept_header_value="application/json",
            http_headers=http_headers,
            security=utils.get_pydantic_model(security, models.ListRefundsSecurity),
            timeout_ms=timeout_ms,
        )

        if retries == UNSET:
            if self.sdk_configuration.retry_config is not UNSET:
                retries = self.sdk_configuration.retry_config

        retry_config = None
        if isinstance(retries, utils.RetryConfig):
            retry_config = (retries, ["429", "500", "502", "503", "504"])

        http_res = await self.do_request_async(
            hook_ctx=HookContext(
                operation_id="listRefunds", oauth2_scopes=[], security_source=security
            ),
            request=req,
            error_status_codes=["401", "403", "429", "4XX", "500", "504", "5XX"],
            retry_config=retry_config,
        )

        if utils.match_response(http_res, "200", "application/json"):
            return utils.unmarshal_json(http_res.text, List[models.CardAcquiringRefund])
        if utils.match_response(http_res, ["401", "403", "429", "4XX"], "*"):
            http_res_text = await utils.stream_to_text_async(http_res)
            raise models.APIError(
                "API error occurred", http_res.status_code, http_res_text, http_res
            )
        if utils.match_response(http_res, ["500", "504", "5XX"], "*"):
            http_res_text = await utils.stream_to_text_async(http_res)
            raise models.APIError(
                "API error occurred", http_res.status_code, http_res_text, http_res
            )

        content_type = http_res.headers.get("Content-Type")
        http_res_text = await utils.stream_to_text_async(http_res)
        raise models.APIError(
            f"Unexpected response received (code: {http_res.status_code}, type: {content_type})",
            http_res.status_code,
            http_res_text,
            http_res,
        )

    def get_refund(
        self,
        *,
        security: Union[models.GetRefundSecurity, models.GetRefundSecurityTypedDict],
        transfer_id: str,
        account_id: str,
        refund_id: str,
        x_moov_version: Optional[models.Versions] = None,
        retries: OptionalNullable[utils.RetryConfig] = UNSET,
        server_url: Optional[str] = None,
        timeout_ms: Optional[int] = None,
        http_headers: Optional[Mapping[str, str]] = None,
    ) -> models.CardAcquiringRefund:
        r"""Get details of a refund for a card transfer.

        To access this endpoint using a [token](https://docs.moov.io/api/authentication/access-tokens/) you'll need to specify the `/accounts/{accountID}/transfers.read`
        scope.

        :param security:
        :param transfer_id: Identifier for the transfer.
        :param account_id:
        :param refund_id: Identifier for the refund.
        :param x_moov_version: Specify an API version.
        :param retries: Override the default retry configuration for this method
        :param server_url: Override the default server URL for this method
        :param timeout_ms: Override the default request timeout configuration for this method in milliseconds
        :param http_headers: Additional headers to set or replace on requests.
        """
        base_url = None
        url_variables = None
        if timeout_ms is None:
            timeout_ms = self.sdk_configuration.timeout_ms

        if server_url is not None:
            base_url = server_url

        request = models.GetRefundRequest(
            x_moov_version=x_moov_version,
            transfer_id=transfer_id,
            account_id=account_id,
            refund_id=refund_id,
        )

        req = self._build_request(
            method="GET",
            path="/accounts/{accountID}/transfers/{transferID}/refunds/{refundID}",
            base_url=base_url,
            url_variables=url_variables,
            request=request,
            request_body_required=False,
            request_has_path_params=True,
            request_has_query_params=True,
            user_agent_header="user-agent",
            accept_header_value="application/json",
            http_headers=http_headers,
            security=utils.get_pydantic_model(security, models.GetRefundSecurity),
            timeout_ms=timeout_ms,
        )

        if retries == UNSET:
            if self.sdk_configuration.retry_config is not UNSET:
                retries = self.sdk_configuration.retry_config

        retry_config = None
        if isinstance(retries, utils.RetryConfig):
            retry_config = (retries, ["429", "500", "502", "503", "504"])

        http_res = self.do_request(
            hook_ctx=HookContext(
                operation_id="getRefund", oauth2_scopes=[], security_source=security
            ),
            request=req,
            error_status_codes=["401", "403", "404", "429", "4XX", "500", "504", "5XX"],
            retry_config=retry_config,
        )

        if utils.match_response(http_res, "200", "application/json"):
            return utils.unmarshal_json(http_res.text, models.CardAcquiringRefund)
        if utils.match_response(http_res, ["401", "403", "404", "429", "4XX"], "*"):
            http_res_text = utils.stream_to_text(http_res)
            raise models.APIError(
                "API error occurred", http_res.status_code, http_res_text, http_res
            )
        if utils.match_response(http_res, ["500", "504", "5XX"], "*"):
            http_res_text = utils.stream_to_text(http_res)
            raise models.APIError(
                "API error occurred", http_res.status_code, http_res_text, http_res
            )

        content_type = http_res.headers.get("Content-Type")
        http_res_text = utils.stream_to_text(http_res)
        raise models.APIError(
            f"Unexpected response received (code: {http_res.status_code}, type: {content_type})",
            http_res.status_code,
            http_res_text,
            http_res,
        )

    async def get_refund_async(
        self,
        *,
        security: Union[models.GetRefundSecurity, models.GetRefundSecurityTypedDict],
        transfer_id: str,
        account_id: str,
        refund_id: str,
        x_moov_version: Optional[models.Versions] = None,
        retries: OptionalNullable[utils.RetryConfig] = UNSET,
        server_url: Optional[str] = None,
        timeout_ms: Optional[int] = None,
        http_headers: Optional[Mapping[str, str]] = None,
    ) -> models.CardAcquiringRefund:
        r"""Get details of a refund for a card transfer.

        To access this endpoint using a [token](https://docs.moov.io/api/authentication/access-tokens/) you'll need to specify the `/accounts/{accountID}/transfers.read`
        scope.

        :param security:
        :param transfer_id: Identifier for the transfer.
        :param account_id:
        :param refund_id: Identifier for the refund.
        :param x_moov_version: Specify an API version.
        :param retries: Override the default retry configuration for this method
        :param server_url: Override the default server URL for this method
        :param timeout_ms: Override the default request timeout configuration for this method in milliseconds
        :param http_headers: Additional headers to set or replace on requests.
        """
        base_url = None
        url_variables = None
        if timeout_ms is None:
            timeout_ms = self.sdk_configuration.timeout_ms

        if server_url is not None:
            base_url = server_url

        request = models.GetRefundRequest(
            x_moov_version=x_moov_version,
            transfer_id=transfer_id,
            account_id=account_id,
            refund_id=refund_id,
        )

        req = self._build_request_async(
            method="GET",
            path="/accounts/{accountID}/transfers/{transferID}/refunds/{refundID}",
            base_url=base_url,
            url_variables=url_variables,
            request=request,
            request_body_required=False,
            request_has_path_params=True,
            request_has_query_params=True,
            user_agent_header="user-agent",
            accept_header_value="application/json",
            http_headers=http_headers,
            security=utils.get_pydantic_model(security, models.GetRefundSecurity),
            timeout_ms=timeout_ms,
        )

        if retries == UNSET:
            if self.sdk_configuration.retry_config is not UNSET:
                retries = self.sdk_configuration.retry_config

        retry_config = None
        if isinstance(retries, utils.RetryConfig):
            retry_config = (retries, ["429", "500", "502", "503", "504"])

        http_res = await self.do_request_async(
            hook_ctx=HookContext(
                operation_id="getRefund", oauth2_scopes=[], security_source=security
            ),
            request=req,
            error_status_codes=["401", "403", "404", "429", "4XX", "500", "504", "5XX"],
            retry_config=retry_config,
        )

        if utils.match_response(http_res, "200", "application/json"):
            return utils.unmarshal_json(http_res.text, models.CardAcquiringRefund)
        if utils.match_response(http_res, ["401", "403", "404", "429", "4XX"], "*"):
            http_res_text = await utils.stream_to_text_async(http_res)
            raise models.APIError(
                "API error occurred", http_res.status_code, http_res_text, http_res
            )
        if utils.match_response(http_res, ["500", "504", "5XX"], "*"):
            http_res_text = await utils.stream_to_text_async(http_res)
            raise models.APIError(
                "API error occurred", http_res.status_code, http_res_text, http_res
            )

        content_type = http_res.headers.get("Content-Type")
        http_res_text = await utils.stream_to_text_async(http_res)
        raise models.APIError(
            f"Unexpected response received (code: {http_res.status_code}, type: {content_type})",
            http_res.status_code,
            http_res_text,
            http_res,
        )

    def reverse_transfer(
        self,
        *,
        security: Union[
            models.ReverseTransferSecurity, models.ReverseTransferSecurityTypedDict
        ],
        x_idempotency_key: str,
        account_id: str,
        transfer_id: str,
        amount: int,
        x_moov_version: Optional[models.Versions] = None,
        retries: OptionalNullable[utils.RetryConfig] = UNSET,
        server_url: Optional[str] = None,
        timeout_ms: Optional[int] = None,
        http_headers: Optional[Mapping[str, str]] = None,
    ) -> models.Reversal:
        r"""Reverses a card transfer by initiating a cancellation or refund depending on the transaction status.
        Read our [reversals guide](https://docs.moov.io/guides/money-movement/accept-payments/card-acceptance/reversals/)
        to learn more.

        To access this endpoint using a [token](https://docs.moov.io/api/authentication/access-tokens/) you'll need
        to specify the `/accounts/{accountID}/transfers.write` scope.

        :param security:
        :param x_idempotency_key: Prevents duplicate reversals from being created.
        :param account_id: The Moov account ID.
        :param transfer_id: The transfer ID to reverse.
        :param amount: Amount to reverse in cents. Partial amounts will automatically trigger a refund instead of a cancellation.
        :param x_moov_version: Specify an API version.
        :param retries: Override the default retry configuration for this method
        :param server_url: Override the default server URL for this method
        :param timeout_ms: Override the default request timeout configuration for this method in milliseconds
        :param http_headers: Additional headers to set or replace on requests.
        """
        base_url = None
        url_variables = None
        if timeout_ms is None:
            timeout_ms = self.sdk_configuration.timeout_ms

        if server_url is not None:
            base_url = server_url

        request = models.ReverseTransferRequest(
            x_moov_version=x_moov_version,
            x_idempotency_key=x_idempotency_key,
            account_id=account_id,
            transfer_id=transfer_id,
            create_reversal=models.CreateReversal(
                amount=amount,
            ),
        )

        req = self._build_request(
            method="POST",
            path="/accounts/{accountID}/transfers/{transferID}/reversals",
            base_url=base_url,
            url_variables=url_variables,
            request=request,
            request_body_required=False,
            request_has_path_params=True,
            request_has_query_params=True,
            user_agent_header="user-agent",
            accept_header_value="application/json",
            http_headers=http_headers,
            security=utils.get_pydantic_model(security, models.ReverseTransferSecurity),
            get_serialized_body=lambda: utils.serialize_request_body(
                request.create_reversal,
                False,
                True,
                "json",
                Optional[models.CreateReversal],
            ),
            timeout_ms=timeout_ms,
        )

        if retries == UNSET:
            if self.sdk_configuration.retry_config is not UNSET:
                retries = self.sdk_configuration.retry_config

        retry_config = None
        if isinstance(retries, utils.RetryConfig):
            retry_config = (retries, ["429", "500", "502", "503", "504"])

        http_res = self.do_request(
            hook_ctx=HookContext(
                operation_id="reverseTransfer",
                oauth2_scopes=[],
                security_source=security,
            ),
            request=req,
            error_status_codes=[
                "400",
                "401",
                "403",
                "404",
                "409",
                "422",
                "429",
                "4XX",
                "500",
                "504",
                "5XX",
            ],
            retry_config=retry_config,
        )

        data: Any = None
        if utils.match_response(http_res, ["200", "202"], "application/json"):
            return utils.unmarshal_json(http_res.text, models.Reversal)
        if utils.match_response(http_res, ["400", "409"], "application/json"):
            data = utils.unmarshal_json(http_res.text, models.GenericErrorData)
            raise models.GenericError(data=data)
        if utils.match_response(http_res, ["401", "403", "404", "429", "4XX"], "*"):
            http_res_text = utils.stream_to_text(http_res)
            raise models.APIError(
                "API error occurred", http_res.status_code, http_res_text, http_res
            )
        if utils.match_response(http_res, "422", "application/json"):
            data = utils.unmarshal_json(
                http_res.text, models.ReversalValidationErrorData
            )
            raise models.ReversalValidationError(data=data)
        if utils.match_response(http_res, ["500", "504", "5XX"], "*"):
            http_res_text = utils.stream_to_text(http_res)
            raise models.APIError(
                "API error occurred", http_res.status_code, http_res_text, http_res
            )

        content_type = http_res.headers.get("Content-Type")
        http_res_text = utils.stream_to_text(http_res)
        raise models.APIError(
            f"Unexpected response received (code: {http_res.status_code}, type: {content_type})",
            http_res.status_code,
            http_res_text,
            http_res,
        )

    async def reverse_transfer_async(
        self,
        *,
        security: Union[
            models.ReverseTransferSecurity, models.ReverseTransferSecurityTypedDict
        ],
        x_idempotency_key: str,
        account_id: str,
        transfer_id: str,
        amount: int,
        x_moov_version: Optional[models.Versions] = None,
        retries: OptionalNullable[utils.RetryConfig] = UNSET,
        server_url: Optional[str] = None,
        timeout_ms: Optional[int] = None,
        http_headers: Optional[Mapping[str, str]] = None,
    ) -> models.Reversal:
        r"""Reverses a card transfer by initiating a cancellation or refund depending on the transaction status.
        Read our [reversals guide](https://docs.moov.io/guides/money-movement/accept-payments/card-acceptance/reversals/)
        to learn more.

        To access this endpoint using a [token](https://docs.moov.io/api/authentication/access-tokens/) you'll need
        to specify the `/accounts/{accountID}/transfers.write` scope.

        :param security:
        :param x_idempotency_key: Prevents duplicate reversals from being created.
        :param account_id: The Moov account ID.
        :param transfer_id: The transfer ID to reverse.
        :param amount: Amount to reverse in cents. Partial amounts will automatically trigger a refund instead of a cancellation.
        :param x_moov_version: Specify an API version.
        :param retries: Override the default retry configuration for this method
        :param server_url: Override the default server URL for this method
        :param timeout_ms: Override the default request timeout configuration for this method in milliseconds
        :param http_headers: Additional headers to set or replace on requests.
        """
        base_url = None
        url_variables = None
        if timeout_ms is None:
            timeout_ms = self.sdk_configuration.timeout_ms

        if server_url is not None:
            base_url = server_url

        request = models.ReverseTransferRequest(
            x_moov_version=x_moov_version,
            x_idempotency_key=x_idempotency_key,
            account_id=account_id,
            transfer_id=transfer_id,
            create_reversal=models.CreateReversal(
                amount=amount,
            ),
        )

        req = self._build_request_async(
            method="POST",
            path="/accounts/{accountID}/transfers/{transferID}/reversals",
            base_url=base_url,
            url_variables=url_variables,
            request=request,
            request_body_required=False,
            request_has_path_params=True,
            request_has_query_params=True,
            user_agent_header="user-agent",
            accept_header_value="application/json",
            http_headers=http_headers,
            security=utils.get_pydantic_model(security, models.ReverseTransferSecurity),
            get_serialized_body=lambda: utils.serialize_request_body(
                request.create_reversal,
                False,
                True,
                "json",
                Optional[models.CreateReversal],
            ),
            timeout_ms=timeout_ms,
        )

        if retries == UNSET:
            if self.sdk_configuration.retry_config is not UNSET:
                retries = self.sdk_configuration.retry_config

        retry_config = None
        if isinstance(retries, utils.RetryConfig):
            retry_config = (retries, ["429", "500", "502", "503", "504"])

        http_res = await self.do_request_async(
            hook_ctx=HookContext(
                operation_id="reverseTransfer",
                oauth2_scopes=[],
                security_source=security,
            ),
            request=req,
            error_status_codes=[
                "400",
                "401",
                "403",
                "404",
                "409",
                "422",
                "429",
                "4XX",
                "500",
                "504",
                "5XX",
            ],
            retry_config=retry_config,
        )

        data: Any = None
        if utils.match_response(http_res, ["200", "202"], "application/json"):
            return utils.unmarshal_json(http_res.text, models.Reversal)
        if utils.match_response(http_res, ["400", "409"], "application/json"):
            data = utils.unmarshal_json(http_res.text, models.GenericErrorData)
            raise models.GenericError(data=data)
        if utils.match_response(http_res, ["401", "403", "404", "429", "4XX"], "*"):
            http_res_text = await utils.stream_to_text_async(http_res)
            raise models.APIError(
                "API error occurred", http_res.status_code, http_res_text, http_res
            )
        if utils.match_response(http_res, "422", "application/json"):
            data = utils.unmarshal_json(
                http_res.text, models.ReversalValidationErrorData
            )
            raise models.ReversalValidationError(data=data)
        if utils.match_response(http_res, ["500", "504", "5XX"], "*"):
            http_res_text = await utils.stream_to_text_async(http_res)
            raise models.APIError(
                "API error occurred", http_res.status_code, http_res_text, http_res
            )

        content_type = http_res.headers.get("Content-Type")
        http_res_text = await utils.stream_to_text_async(http_res)
        raise models.APIError(
            f"Unexpected response received (code: {http_res.status_code}, type: {content_type})",
            http_res.status_code,
            http_res_text,
            http_res,
        )

    def create_transfer_options(
        self,
        *,
        security: Union[
            models.CreateTransferOptionsSecurity,
            models.CreateTransferOptionsSecurityTypedDict,
        ],
        x_moov_version: Optional[models.Versions] = None,
        retries: OptionalNullable[utils.RetryConfig] = UNSET,
        server_url: Optional[str] = None,
        timeout_ms: Optional[int] = None,
        http_headers: Optional[Mapping[str, str]] = None,
    ) -> models.TransferOptions:
        r"""Generate available payment method options for one or multiple transfer participants depending on the accountID or paymentMethodID you
        supply in the request.

        Read our [transfers overview guide](https://docs.moov.io/guides/money-movement/overview/) to learn more.

        To use this endpoint from the browser, you'll need to specify the `/accounts/{yourAccountID}/transfers.read` scope when generating a
        [token](https://docs.moov.io/api/authentication/access-tokens/). The accountID included must be your accountID. You can find your
        accountID on the [Business details](https://dashboard.moov.io/settings/business) page.

        :param security:
        :param x_moov_version: Specify an API version.
        :param retries: Override the default retry configuration for this method
        :param server_url: Override the default server URL for this method
        :param timeout_ms: Override the default request timeout configuration for this method in milliseconds
        :param http_headers: Additional headers to set or replace on requests.
        """
        base_url = None
        url_variables = None
        if timeout_ms is None:
            timeout_ms = self.sdk_configuration.timeout_ms

        if server_url is not None:
            base_url = server_url

        request = models.CreateTransferOptionsRequest(
            x_moov_version=x_moov_version,
        )

        req = self._build_request(
            method="POST",
            path="/transfer-options",
            base_url=base_url,
            url_variables=url_variables,
            request=request,
            request_body_required=False,
            request_has_path_params=False,
            request_has_query_params=True,
            user_agent_header="user-agent",
            accept_header_value="application/json",
            http_headers=http_headers,
            security=utils.get_pydantic_model(
                security, models.CreateTransferOptionsSecurity
            ),
            timeout_ms=timeout_ms,
        )

        if retries == UNSET:
            if self.sdk_configuration.retry_config is not UNSET:
                retries = self.sdk_configuration.retry_config

        retry_config = None
        if isinstance(retries, utils.RetryConfig):
            retry_config = (retries, ["429", "500", "502", "503", "504"])

        http_res = self.do_request(
            hook_ctx=HookContext(
                operation_id="createTransferOptions",
                oauth2_scopes=[],
                security_source=security,
            ),
            request=req,
            error_status_codes=[
                "400",
                "401",
                "403",
                "422",
                "429",
                "4XX",
                "500",
                "504",
                "5XX",
            ],
            retry_config=retry_config,
        )

        data: Any = None
        if utils.match_response(http_res, "200", "application/json"):
            return utils.unmarshal_json(http_res.text, models.TransferOptions)
        if utils.match_response(http_res, "400", "application/json"):
            data = utils.unmarshal_json(http_res.text, models.GenericErrorData)
            raise models.GenericError(data=data)
        if utils.match_response(http_res, ["401", "403", "429", "4XX"], "*"):
            http_res_text = utils.stream_to_text(http_res)
            raise models.APIError(
                "API error occurred", http_res.status_code, http_res_text, http_res
            )
        if utils.match_response(http_res, "422", "application/json"):
            data = utils.unmarshal_json(
                http_res.text, models.TransferOptionsValidationErrorData
            )
            raise models.TransferOptionsValidationError(data=data)
        if utils.match_response(http_res, ["500", "504", "5XX"], "*"):
            http_res_text = utils.stream_to_text(http_res)
            raise models.APIError(
                "API error occurred", http_res.status_code, http_res_text, http_res
            )

        content_type = http_res.headers.get("Content-Type")
        http_res_text = utils.stream_to_text(http_res)
        raise models.APIError(
            f"Unexpected response received (code: {http_res.status_code}, type: {content_type})",
            http_res.status_code,
            http_res_text,
            http_res,
        )

    async def create_transfer_options_async(
        self,
        *,
        security: Union[
            models.CreateTransferOptionsSecurity,
            models.CreateTransferOptionsSecurityTypedDict,
        ],
        x_moov_version: Optional[models.Versions] = None,
        retries: OptionalNullable[utils.RetryConfig] = UNSET,
        server_url: Optional[str] = None,
        timeout_ms: Optional[int] = None,
        http_headers: Optional[Mapping[str, str]] = None,
    ) -> models.TransferOptions:
        r"""Generate available payment method options for one or multiple transfer participants depending on the accountID or paymentMethodID you
        supply in the request.

        Read our [transfers overview guide](https://docs.moov.io/guides/money-movement/overview/) to learn more.

        To use this endpoint from the browser, you'll need to specify the `/accounts/{yourAccountID}/transfers.read` scope when generating a
        [token](https://docs.moov.io/api/authentication/access-tokens/). The accountID included must be your accountID. You can find your
        accountID on the [Business details](https://dashboard.moov.io/settings/business) page.

        :param security:
        :param x_moov_version: Specify an API version.
        :param retries: Override the default retry configuration for this method
        :param server_url: Override the default server URL for this method
        :param timeout_ms: Override the default request timeout configuration for this method in milliseconds
        :param http_headers: Additional headers to set or replace on requests.
        """
        base_url = None
        url_variables = None
        if timeout_ms is None:
            timeout_ms = self.sdk_configuration.timeout_ms

        if server_url is not None:
            base_url = server_url

        request = models.CreateTransferOptionsRequest(
            x_moov_version=x_moov_version,
        )

        req = self._build_request_async(
            method="POST",
            path="/transfer-options",
            base_url=base_url,
            url_variables=url_variables,
            request=request,
            request_body_required=False,
            request_has_path_params=False,
            request_has_query_params=True,
            user_agent_header="user-agent",
            accept_header_value="application/json",
            http_headers=http_headers,
            security=utils.get_pydantic_model(
                security, models.CreateTransferOptionsSecurity
            ),
            timeout_ms=timeout_ms,
        )

        if retries == UNSET:
            if self.sdk_configuration.retry_config is not UNSET:
                retries = self.sdk_configuration.retry_config

        retry_config = None
        if isinstance(retries, utils.RetryConfig):
            retry_config = (retries, ["429", "500", "502", "503", "504"])

        http_res = await self.do_request_async(
            hook_ctx=HookContext(
                operation_id="createTransferOptions",
                oauth2_scopes=[],
                security_source=security,
            ),
            request=req,
            error_status_codes=[
                "400",
                "401",
                "403",
                "422",
                "429",
                "4XX",
                "500",
                "504",
                "5XX",
            ],
            retry_config=retry_config,
        )

        data: Any = None
        if utils.match_response(http_res, "200", "application/json"):
            return utils.unmarshal_json(http_res.text, models.TransferOptions)
        if utils.match_response(http_res, "400", "application/json"):
            data = utils.unmarshal_json(http_res.text, models.GenericErrorData)
            raise models.GenericError(data=data)
        if utils.match_response(http_res, ["401", "403", "429", "4XX"], "*"):
            http_res_text = await utils.stream_to_text_async(http_res)
            raise models.APIError(
                "API error occurred", http_res.status_code, http_res_text, http_res
            )
        if utils.match_response(http_res, "422", "application/json"):
            data = utils.unmarshal_json(
                http_res.text, models.TransferOptionsValidationErrorData
            )
            raise models.TransferOptionsValidationError(data=data)
        if utils.match_response(http_res, ["500", "504", "5XX"], "*"):
            http_res_text = await utils.stream_to_text_async(http_res)
            raise models.APIError(
                "API error occurred", http_res.status_code, http_res_text, http_res
            )

        content_type = http_res.headers.get("Content-Type")
        http_res_text = await utils.stream_to_text_async(http_res)
        raise models.APIError(
            f"Unexpected response received (code: {http_res.status_code}, type: {content_type})",
            http_res.status_code,
            http_res_text,
            http_res,
        )
