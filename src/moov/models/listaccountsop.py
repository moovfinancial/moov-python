"""Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT."""

from __future__ import annotations
from .accounttype import AccountType
from .capabilityid import CapabilityID
from .capabilitystatus import CapabilityStatus
from .schemebasicauth import SchemeBasicAuth, SchemeBasicAuthTypedDict
from .versions import Versions
from moov.types import BaseModel
from moov.utils import (
    FieldMetadata,
    HeaderMetadata,
    QueryParamMetadata,
    SecurityMetadata,
)
import pydantic
from typing import Optional
from typing_extensions import Annotated, NotRequired, TypedDict


class ListAccountsSecurityTypedDict(TypedDict):
    basic_auth: NotRequired[SchemeBasicAuthTypedDict]
    o_auth2_auth: NotRequired[str]


class ListAccountsSecurity(BaseModel):
    basic_auth: Annotated[
        Optional[SchemeBasicAuth],
        FieldMetadata(
            security=SecurityMetadata(scheme=True, scheme_type="http", sub_type="basic")
        ),
    ] = None

    o_auth2_auth: Annotated[
        Optional[str],
        FieldMetadata(
            security=SecurityMetadata(
                scheme=True, scheme_type="oauth2", field_name="Authorization"
            )
        ),
    ] = None


class ListAccountsRequestTypedDict(TypedDict):
    x_moov_version: NotRequired[Versions]
    r"""Specify an API version."""
    name: NotRequired[str]
    r"""Filter connected accounts by name.

    If provided, this query will attempt to find matches against the following Account and Profile fields:
    <ul>
    <li>Account `displayName`</li>
    <li>Individual Profile `firstName`, `middleName`, and `lastName`</li>
    <li>Business Profile `legalBusinessName`</li>
    </ul>
    """
    email: NotRequired[str]
    r"""Filter connected accounts by email address.

    Provide the full email address to filter by email.
    """
    type: NotRequired[AccountType]
    r"""Filter connected accounts by AccountType.

    If the `type` parameter is used in combination with `name`, only the corresponding type's name fields will
    be searched. For example, if `type=business` and `name=moov`, the search will attempt to find matches against
    the display name and Business Profile name fields (`legalBusinessName`, and `doingBusinessAs`).
    """
    foreign_id: NotRequired[str]
    r"""Serves as an optional alias from a foreign/external system which can be used to reference this resource."""
    include_disconnected: NotRequired[bool]
    r"""Filter disconnected accounts.

    If true, the response will include disconnected accounts.
    """
    capability: NotRequired[CapabilityID]
    r"""Filter connected accounts by the capability."""
    capability_status: NotRequired[CapabilityStatus]
    r"""Filter connected accounts by the capability."""
    skip: NotRequired[int]
    count: NotRequired[int]


class ListAccountsRequest(BaseModel):
    x_moov_version: Annotated[
        Optional[Versions],
        pydantic.Field(alias="x-moov-version"),
        FieldMetadata(header=HeaderMetadata(style="simple", explode=False)),
    ] = None
    r"""Specify an API version."""

    name: Annotated[
        Optional[str],
        FieldMetadata(query=QueryParamMetadata(style="form", explode=False)),
    ] = None
    r"""Filter connected accounts by name.

    If provided, this query will attempt to find matches against the following Account and Profile fields:
    <ul>
    <li>Account `displayName`</li>
    <li>Individual Profile `firstName`, `middleName`, and `lastName`</li>
    <li>Business Profile `legalBusinessName`</li>
    </ul>
    """

    email: Annotated[
        Optional[str],
        FieldMetadata(query=QueryParamMetadata(style="form", explode=False)),
    ] = None
    r"""Filter connected accounts by email address.

    Provide the full email address to filter by email.
    """

    type: Annotated[
        Optional[AccountType],
        FieldMetadata(query=QueryParamMetadata(style="form", explode=False)),
    ] = None
    r"""Filter connected accounts by AccountType.

    If the `type` parameter is used in combination with `name`, only the corresponding type's name fields will
    be searched. For example, if `type=business` and `name=moov`, the search will attempt to find matches against
    the display name and Business Profile name fields (`legalBusinessName`, and `doingBusinessAs`).
    """

    foreign_id: Annotated[
        Optional[str],
        pydantic.Field(alias="foreignID"),
        FieldMetadata(query=QueryParamMetadata(style="form", explode=False)),
    ] = None
    r"""Serves as an optional alias from a foreign/external system which can be used to reference this resource."""

    include_disconnected: Annotated[
        Optional[bool],
        pydantic.Field(alias="includeDisconnected"),
        FieldMetadata(query=QueryParamMetadata(style="form", explode=False)),
    ] = None
    r"""Filter disconnected accounts.

    If true, the response will include disconnected accounts.
    """

    capability: Annotated[
        Optional[CapabilityID],
        FieldMetadata(query=QueryParamMetadata(style="form", explode=False)),
    ] = None
    r"""Filter connected accounts by the capability."""

    capability_status: Annotated[
        Optional[CapabilityStatus],
        pydantic.Field(alias="capabilityStatus"),
        FieldMetadata(query=QueryParamMetadata(style="form", explode=False)),
    ] = None
    r"""Filter connected accounts by the capability."""

    skip: Annotated[
        Optional[int],
        FieldMetadata(query=QueryParamMetadata(style="form", explode=False)),
    ] = None

    count: Annotated[
        Optional[int],
        FieldMetadata(query=QueryParamMetadata(style="form", explode=False)),
    ] = None
