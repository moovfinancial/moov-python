"""Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT."""

from .basesdk import BaseSDK
from moovio_sdk import utils
from moovio_sdk._hooks import HookContext
from moovio_sdk.models import components, errors, operations
from moovio_sdk.types import OptionalNullable, UNSET
from moovio_sdk.utils import get_security_from_env
from typing import Any, List, Mapping, Optional, Union


class Cards(BaseSDK):
    def register_apple_pay_merchant_domains(
        self,
        *,
        security: Union[
            operations.RegisterApplePayMerchantDomainsSecurity,
            operations.RegisterApplePayMerchantDomainsSecurityTypedDict,
        ],
        account_id: str,
        x_moov_version: Optional[components.Versions] = None,
        display_name: Optional[str] = None,
        domains: Optional[List[str]] = None,
        retries: OptionalNullable[utils.RetryConfig] = UNSET,
        server_url: Optional[str] = None,
        timeout_ms: Optional[int] = None,
        http_headers: Optional[Mapping[str, str]] = None,
    ) -> components.ApplePayMerchantDomains:
        r"""Add domains to be registered with Apple Pay.

        Any domains that will be used to accept payments must first be [verified](https://docs.moov.io/guides/sources/cards/apple-pay/#register-your-domains)
        with Apple.

        To use this endpoint from the browser, you'll need to specify the `/accounts/{accountID}/apple-pay.write` scope when generating a
        [token](https://docs.moov.io/api/authentication/access-tokens/).

        :param security:
        :param account_id: ID of the Moov account representing the merchant.
        :param x_moov_version: Specify an API version.
        :param display_name: A UTF-8 string to display in the Buy button.
        :param domains: A unique list of fully-qualified, top-level or sub-domain names where you will accept Apple Pay.
        :param retries: Override the default retry configuration for this method
        :param server_url: Override the default server URL for this method
        :param timeout_ms: Override the default request timeout configuration for this method in milliseconds
        :param http_headers: Additional headers to set or replace on requests.
        """
        base_url = None
        url_variables = None
        if timeout_ms is None:
            timeout_ms = self.sdk_configuration.timeout_ms

        if server_url is not None:
            base_url = server_url

        request = operations.RegisterApplePayMerchantDomainsRequest(
            x_moov_version=x_moov_version,
            account_id=account_id,
            register_apple_pay_merchant_domains=components.RegisterApplePayMerchantDomains(
                display_name=display_name,
                domains=domains,
            ),
        )

        req = self._build_request(
            method="POST",
            path="/accounts/{accountID}/apple-pay/domains",
            base_url=base_url,
            url_variables=url_variables,
            request=request,
            request_body_required=True,
            request_has_path_params=True,
            request_has_query_params=True,
            user_agent_header="user-agent",
            accept_header_value="application/json",
            http_headers=http_headers,
            security=utils.get_pydantic_model(
                security, operations.RegisterApplePayMerchantDomainsSecurity
            ),
            get_serialized_body=lambda: utils.serialize_request_body(
                request.register_apple_pay_merchant_domains,
                False,
                False,
                "json",
                components.RegisterApplePayMerchantDomains,
            ),
            timeout_ms=timeout_ms,
        )

        if retries == UNSET:
            if self.sdk_configuration.retry_config is not UNSET:
                retries = self.sdk_configuration.retry_config

        retry_config = None
        if isinstance(retries, utils.RetryConfig):
            retry_config = (retries, ["429", "500", "502", "503", "504"])

        http_res = self.do_request(
            hook_ctx=HookContext(
                operation_id="registerApplePayMerchantDomains",
                oauth2_scopes=[],
                security_source=get_security_from_env(security, components.Security),
            ),
            request=req,
            error_status_codes=[
                "400",
                "401",
                "403",
                "409",
                "417",
                "429",
                "4XX",
                "500",
                "504",
                "5XX",
            ],
            retry_config=retry_config,
        )

        data: Any = None
        if utils.match_response(http_res, "200", "application/json"):
            return utils.unmarshal_json(
                http_res.text, components.ApplePayMerchantDomains
            )
        if utils.match_response(http_res, "400", "application/json"):
            data = utils.unmarshal_json(http_res.text, errors.GenericErrorData)
            raise errors.GenericError(data=data)
        if utils.match_response(
            http_res, ["401", "403", "409", "417", "429", "4XX"], "*"
        ):
            http_res_text = utils.stream_to_text(http_res)
            raise errors.APIError(
                "API error occurred", http_res.status_code, http_res_text, http_res
            )
        if utils.match_response(http_res, ["500", "504", "5XX"], "*"):
            http_res_text = utils.stream_to_text(http_res)
            raise errors.APIError(
                "API error occurred", http_res.status_code, http_res_text, http_res
            )

        content_type = http_res.headers.get("Content-Type")
        http_res_text = utils.stream_to_text(http_res)
        raise errors.APIError(
            f"Unexpected response received (code: {http_res.status_code}, type: {content_type})",
            http_res.status_code,
            http_res_text,
            http_res,
        )

    async def register_apple_pay_merchant_domains_async(
        self,
        *,
        security: Union[
            operations.RegisterApplePayMerchantDomainsSecurity,
            operations.RegisterApplePayMerchantDomainsSecurityTypedDict,
        ],
        account_id: str,
        x_moov_version: Optional[components.Versions] = None,
        display_name: Optional[str] = None,
        domains: Optional[List[str]] = None,
        retries: OptionalNullable[utils.RetryConfig] = UNSET,
        server_url: Optional[str] = None,
        timeout_ms: Optional[int] = None,
        http_headers: Optional[Mapping[str, str]] = None,
    ) -> components.ApplePayMerchantDomains:
        r"""Add domains to be registered with Apple Pay.

        Any domains that will be used to accept payments must first be [verified](https://docs.moov.io/guides/sources/cards/apple-pay/#register-your-domains)
        with Apple.

        To use this endpoint from the browser, you'll need to specify the `/accounts/{accountID}/apple-pay.write` scope when generating a
        [token](https://docs.moov.io/api/authentication/access-tokens/).

        :param security:
        :param account_id: ID of the Moov account representing the merchant.
        :param x_moov_version: Specify an API version.
        :param display_name: A UTF-8 string to display in the Buy button.
        :param domains: A unique list of fully-qualified, top-level or sub-domain names where you will accept Apple Pay.
        :param retries: Override the default retry configuration for this method
        :param server_url: Override the default server URL for this method
        :param timeout_ms: Override the default request timeout configuration for this method in milliseconds
        :param http_headers: Additional headers to set or replace on requests.
        """
        base_url = None
        url_variables = None
        if timeout_ms is None:
            timeout_ms = self.sdk_configuration.timeout_ms

        if server_url is not None:
            base_url = server_url

        request = operations.RegisterApplePayMerchantDomainsRequest(
            x_moov_version=x_moov_version,
            account_id=account_id,
            register_apple_pay_merchant_domains=components.RegisterApplePayMerchantDomains(
                display_name=display_name,
                domains=domains,
            ),
        )

        req = self._build_request_async(
            method="POST",
            path="/accounts/{accountID}/apple-pay/domains",
            base_url=base_url,
            url_variables=url_variables,
            request=request,
            request_body_required=True,
            request_has_path_params=True,
            request_has_query_params=True,
            user_agent_header="user-agent",
            accept_header_value="application/json",
            http_headers=http_headers,
            security=utils.get_pydantic_model(
                security, operations.RegisterApplePayMerchantDomainsSecurity
            ),
            get_serialized_body=lambda: utils.serialize_request_body(
                request.register_apple_pay_merchant_domains,
                False,
                False,
                "json",
                components.RegisterApplePayMerchantDomains,
            ),
            timeout_ms=timeout_ms,
        )

        if retries == UNSET:
            if self.sdk_configuration.retry_config is not UNSET:
                retries = self.sdk_configuration.retry_config

        retry_config = None
        if isinstance(retries, utils.RetryConfig):
            retry_config = (retries, ["429", "500", "502", "503", "504"])

        http_res = await self.do_request_async(
            hook_ctx=HookContext(
                operation_id="registerApplePayMerchantDomains",
                oauth2_scopes=[],
                security_source=get_security_from_env(security, components.Security),
            ),
            request=req,
            error_status_codes=[
                "400",
                "401",
                "403",
                "409",
                "417",
                "429",
                "4XX",
                "500",
                "504",
                "5XX",
            ],
            retry_config=retry_config,
        )

        data: Any = None
        if utils.match_response(http_res, "200", "application/json"):
            return utils.unmarshal_json(
                http_res.text, components.ApplePayMerchantDomains
            )
        if utils.match_response(http_res, "400", "application/json"):
            data = utils.unmarshal_json(http_res.text, errors.GenericErrorData)
            raise errors.GenericError(data=data)
        if utils.match_response(
            http_res, ["401", "403", "409", "417", "429", "4XX"], "*"
        ):
            http_res_text = await utils.stream_to_text_async(http_res)
            raise errors.APIError(
                "API error occurred", http_res.status_code, http_res_text, http_res
            )
        if utils.match_response(http_res, ["500", "504", "5XX"], "*"):
            http_res_text = await utils.stream_to_text_async(http_res)
            raise errors.APIError(
                "API error occurred", http_res.status_code, http_res_text, http_res
            )

        content_type = http_res.headers.get("Content-Type")
        http_res_text = await utils.stream_to_text_async(http_res)
        raise errors.APIError(
            f"Unexpected response received (code: {http_res.status_code}, type: {content_type})",
            http_res.status_code,
            http_res_text,
            http_res,
        )

    def update_apple_pay_merchant_domains(
        self,
        *,
        security: Union[
            operations.UpdateApplePayMerchantDomainsSecurity,
            operations.UpdateApplePayMerchantDomainsSecurityTypedDict,
        ],
        account_id: str,
        x_moov_version: Optional[components.Versions] = None,
        add_domains: Optional[List[str]] = None,
        remove_domains: Optional[List[str]] = None,
        retries: OptionalNullable[utils.RetryConfig] = UNSET,
        server_url: Optional[str] = None,
        timeout_ms: Optional[int] = None,
        http_headers: Optional[Mapping[str, str]] = None,
    ):
        r"""Add or remove domains to be registered with Apple Pay.

          Any domains that will be used to accept payments must first be [verified](https://docs.moov.io/guides/sources/cards/apple-pay/#register-your-domains)
          with Apple.

          To use this endpoint from the browser, you'll need to specify the `/accounts/{accountID}/apple-pay.write` scope when generating a
          [token](https://docs.moov.io/api/authentication/access-tokens/).

        :param security:
        :param account_id: ID of the Moov account representing the merchant.
        :param x_moov_version: Specify an API version.
        :param add_domains: A unique list of fully-qualified, top-level or sub-domain names to add.
        :param remove_domains: A unique list of fully-qualified, top-level or sub-domain names to remove.
        :param retries: Override the default retry configuration for this method
        :param server_url: Override the default server URL for this method
        :param timeout_ms: Override the default request timeout configuration for this method in milliseconds
        :param http_headers: Additional headers to set or replace on requests.
        """
        base_url = None
        url_variables = None
        if timeout_ms is None:
            timeout_ms = self.sdk_configuration.timeout_ms

        if server_url is not None:
            base_url = server_url

        request = operations.UpdateApplePayMerchantDomainsRequest(
            x_moov_version=x_moov_version,
            account_id=account_id,
            update_apple_pay_merchant_domains=components.UpdateApplePayMerchantDomains(
                add_domains=add_domains,
                remove_domains=remove_domains,
            ),
        )

        req = self._build_request(
            method="PATCH",
            path="/accounts/{accountID}/apple-pay/domains",
            base_url=base_url,
            url_variables=url_variables,
            request=request,
            request_body_required=True,
            request_has_path_params=True,
            request_has_query_params=True,
            user_agent_header="user-agent",
            accept_header_value="application/json",
            http_headers=http_headers,
            security=utils.get_pydantic_model(
                security, operations.UpdateApplePayMerchantDomainsSecurity
            ),
            get_serialized_body=lambda: utils.serialize_request_body(
                request.update_apple_pay_merchant_domains,
                False,
                False,
                "json",
                components.UpdateApplePayMerchantDomains,
            ),
            timeout_ms=timeout_ms,
        )

        if retries == UNSET:
            if self.sdk_configuration.retry_config is not UNSET:
                retries = self.sdk_configuration.retry_config

        retry_config = None
        if isinstance(retries, utils.RetryConfig):
            retry_config = (retries, ["429", "500", "502", "503", "504"])

        http_res = self.do_request(
            hook_ctx=HookContext(
                operation_id="updateApplePayMerchantDomains",
                oauth2_scopes=[],
                security_source=get_security_from_env(security, components.Security),
            ),
            request=req,
            error_status_codes=[
                "400",
                "401",
                "403",
                "404",
                "409",
                "417",
                "429",
                "4XX",
                "500",
                "504",
                "5XX",
            ],
            retry_config=retry_config,
        )

        data: Any = None
        if utils.match_response(http_res, "204", "*"):
            return
        if utils.match_response(http_res, "400", "application/json"):
            data = utils.unmarshal_json(http_res.text, errors.GenericErrorData)
            raise errors.GenericError(data=data)
        if utils.match_response(
            http_res, ["401", "403", "404", "409", "417", "429", "4XX"], "*"
        ):
            http_res_text = utils.stream_to_text(http_res)
            raise errors.APIError(
                "API error occurred", http_res.status_code, http_res_text, http_res
            )
        if utils.match_response(http_res, ["500", "504", "5XX"], "*"):
            http_res_text = utils.stream_to_text(http_res)
            raise errors.APIError(
                "API error occurred", http_res.status_code, http_res_text, http_res
            )

        content_type = http_res.headers.get("Content-Type")
        http_res_text = utils.stream_to_text(http_res)
        raise errors.APIError(
            f"Unexpected response received (code: {http_res.status_code}, type: {content_type})",
            http_res.status_code,
            http_res_text,
            http_res,
        )

    async def update_apple_pay_merchant_domains_async(
        self,
        *,
        security: Union[
            operations.UpdateApplePayMerchantDomainsSecurity,
            operations.UpdateApplePayMerchantDomainsSecurityTypedDict,
        ],
        account_id: str,
        x_moov_version: Optional[components.Versions] = None,
        add_domains: Optional[List[str]] = None,
        remove_domains: Optional[List[str]] = None,
        retries: OptionalNullable[utils.RetryConfig] = UNSET,
        server_url: Optional[str] = None,
        timeout_ms: Optional[int] = None,
        http_headers: Optional[Mapping[str, str]] = None,
    ):
        r"""Add or remove domains to be registered with Apple Pay.

          Any domains that will be used to accept payments must first be [verified](https://docs.moov.io/guides/sources/cards/apple-pay/#register-your-domains)
          with Apple.

          To use this endpoint from the browser, you'll need to specify the `/accounts/{accountID}/apple-pay.write` scope when generating a
          [token](https://docs.moov.io/api/authentication/access-tokens/).

        :param security:
        :param account_id: ID of the Moov account representing the merchant.
        :param x_moov_version: Specify an API version.
        :param add_domains: A unique list of fully-qualified, top-level or sub-domain names to add.
        :param remove_domains: A unique list of fully-qualified, top-level or sub-domain names to remove.
        :param retries: Override the default retry configuration for this method
        :param server_url: Override the default server URL for this method
        :param timeout_ms: Override the default request timeout configuration for this method in milliseconds
        :param http_headers: Additional headers to set or replace on requests.
        """
        base_url = None
        url_variables = None
        if timeout_ms is None:
            timeout_ms = self.sdk_configuration.timeout_ms

        if server_url is not None:
            base_url = server_url

        request = operations.UpdateApplePayMerchantDomainsRequest(
            x_moov_version=x_moov_version,
            account_id=account_id,
            update_apple_pay_merchant_domains=components.UpdateApplePayMerchantDomains(
                add_domains=add_domains,
                remove_domains=remove_domains,
            ),
        )

        req = self._build_request_async(
            method="PATCH",
            path="/accounts/{accountID}/apple-pay/domains",
            base_url=base_url,
            url_variables=url_variables,
            request=request,
            request_body_required=True,
            request_has_path_params=True,
            request_has_query_params=True,
            user_agent_header="user-agent",
            accept_header_value="application/json",
            http_headers=http_headers,
            security=utils.get_pydantic_model(
                security, operations.UpdateApplePayMerchantDomainsSecurity
            ),
            get_serialized_body=lambda: utils.serialize_request_body(
                request.update_apple_pay_merchant_domains,
                False,
                False,
                "json",
                components.UpdateApplePayMerchantDomains,
            ),
            timeout_ms=timeout_ms,
        )

        if retries == UNSET:
            if self.sdk_configuration.retry_config is not UNSET:
                retries = self.sdk_configuration.retry_config

        retry_config = None
        if isinstance(retries, utils.RetryConfig):
            retry_config = (retries, ["429", "500", "502", "503", "504"])

        http_res = await self.do_request_async(
            hook_ctx=HookContext(
                operation_id="updateApplePayMerchantDomains",
                oauth2_scopes=[],
                security_source=get_security_from_env(security, components.Security),
            ),
            request=req,
            error_status_codes=[
                "400",
                "401",
                "403",
                "404",
                "409",
                "417",
                "429",
                "4XX",
                "500",
                "504",
                "5XX",
            ],
            retry_config=retry_config,
        )

        data: Any = None
        if utils.match_response(http_res, "204", "*"):
            return
        if utils.match_response(http_res, "400", "application/json"):
            data = utils.unmarshal_json(http_res.text, errors.GenericErrorData)
            raise errors.GenericError(data=data)
        if utils.match_response(
            http_res, ["401", "403", "404", "409", "417", "429", "4XX"], "*"
        ):
            http_res_text = await utils.stream_to_text_async(http_res)
            raise errors.APIError(
                "API error occurred", http_res.status_code, http_res_text, http_res
            )
        if utils.match_response(http_res, ["500", "504", "5XX"], "*"):
            http_res_text = await utils.stream_to_text_async(http_res)
            raise errors.APIError(
                "API error occurred", http_res.status_code, http_res_text, http_res
            )

        content_type = http_res.headers.get("Content-Type")
        http_res_text = await utils.stream_to_text_async(http_res)
        raise errors.APIError(
            f"Unexpected response received (code: {http_res.status_code}, type: {content_type})",
            http_res.status_code,
            http_res_text,
            http_res,
        )

    def get_apple_pay_merchant_domains(
        self,
        *,
        security: Union[
            operations.GetApplePayMerchantDomainsSecurity,
            operations.GetApplePayMerchantDomainsSecurityTypedDict,
        ],
        account_id: str,
        x_moov_version: Optional[components.Versions] = None,
        retries: OptionalNullable[utils.RetryConfig] = UNSET,
        server_url: Optional[str] = None,
        timeout_ms: Optional[int] = None,
        http_headers: Optional[Mapping[str, str]] = None,
    ) -> components.ApplePayMerchantDomains:
        r"""Get domains registered with Apple Pay.

          Read our [Apple Pay tutorial](https://docs.moov.io/guides/sources/cards/apple-pay/#register-your-domains) to learn more.

          To use this endpoint from the browser, you'll need to specify the `/accounts/{accountID}/apple-pay.read` scope when generating a
          [token](https://docs.moov.io/api/authentication/access-tokens/).

        :param security:
        :param account_id: ID of the Moov account representing the merchant.
        :param x_moov_version: Specify an API version.
        :param retries: Override the default retry configuration for this method
        :param server_url: Override the default server URL for this method
        :param timeout_ms: Override the default request timeout configuration for this method in milliseconds
        :param http_headers: Additional headers to set or replace on requests.
        """
        base_url = None
        url_variables = None
        if timeout_ms is None:
            timeout_ms = self.sdk_configuration.timeout_ms

        if server_url is not None:
            base_url = server_url

        request = operations.GetApplePayMerchantDomainsRequest(
            x_moov_version=x_moov_version,
            account_id=account_id,
        )

        req = self._build_request(
            method="GET",
            path="/accounts/{accountID}/apple-pay/domains",
            base_url=base_url,
            url_variables=url_variables,
            request=request,
            request_body_required=False,
            request_has_path_params=True,
            request_has_query_params=True,
            user_agent_header="user-agent",
            accept_header_value="application/json",
            http_headers=http_headers,
            security=utils.get_pydantic_model(
                security, operations.GetApplePayMerchantDomainsSecurity
            ),
            timeout_ms=timeout_ms,
        )

        if retries == UNSET:
            if self.sdk_configuration.retry_config is not UNSET:
                retries = self.sdk_configuration.retry_config

        retry_config = None
        if isinstance(retries, utils.RetryConfig):
            retry_config = (retries, ["429", "500", "502", "503", "504"])

        http_res = self.do_request(
            hook_ctx=HookContext(
                operation_id="getApplePayMerchantDomains",
                oauth2_scopes=[],
                security_source=get_security_from_env(security, components.Security),
            ),
            request=req,
            error_status_codes=["401", "403", "404", "429", "4XX", "500", "504", "5XX"],
            retry_config=retry_config,
        )

        if utils.match_response(http_res, "200", "application/json"):
            return utils.unmarshal_json(
                http_res.text, components.ApplePayMerchantDomains
            )
        if utils.match_response(http_res, ["401", "403", "404", "429", "4XX"], "*"):
            http_res_text = utils.stream_to_text(http_res)
            raise errors.APIError(
                "API error occurred", http_res.status_code, http_res_text, http_res
            )
        if utils.match_response(http_res, ["500", "504", "5XX"], "*"):
            http_res_text = utils.stream_to_text(http_res)
            raise errors.APIError(
                "API error occurred", http_res.status_code, http_res_text, http_res
            )

        content_type = http_res.headers.get("Content-Type")
        http_res_text = utils.stream_to_text(http_res)
        raise errors.APIError(
            f"Unexpected response received (code: {http_res.status_code}, type: {content_type})",
            http_res.status_code,
            http_res_text,
            http_res,
        )

    async def get_apple_pay_merchant_domains_async(
        self,
        *,
        security: Union[
            operations.GetApplePayMerchantDomainsSecurity,
            operations.GetApplePayMerchantDomainsSecurityTypedDict,
        ],
        account_id: str,
        x_moov_version: Optional[components.Versions] = None,
        retries: OptionalNullable[utils.RetryConfig] = UNSET,
        server_url: Optional[str] = None,
        timeout_ms: Optional[int] = None,
        http_headers: Optional[Mapping[str, str]] = None,
    ) -> components.ApplePayMerchantDomains:
        r"""Get domains registered with Apple Pay.

          Read our [Apple Pay tutorial](https://docs.moov.io/guides/sources/cards/apple-pay/#register-your-domains) to learn more.

          To use this endpoint from the browser, you'll need to specify the `/accounts/{accountID}/apple-pay.read` scope when generating a
          [token](https://docs.moov.io/api/authentication/access-tokens/).

        :param security:
        :param account_id: ID of the Moov account representing the merchant.
        :param x_moov_version: Specify an API version.
        :param retries: Override the default retry configuration for this method
        :param server_url: Override the default server URL for this method
        :param timeout_ms: Override the default request timeout configuration for this method in milliseconds
        :param http_headers: Additional headers to set or replace on requests.
        """
        base_url = None
        url_variables = None
        if timeout_ms is None:
            timeout_ms = self.sdk_configuration.timeout_ms

        if server_url is not None:
            base_url = server_url

        request = operations.GetApplePayMerchantDomainsRequest(
            x_moov_version=x_moov_version,
            account_id=account_id,
        )

        req = self._build_request_async(
            method="GET",
            path="/accounts/{accountID}/apple-pay/domains",
            base_url=base_url,
            url_variables=url_variables,
            request=request,
            request_body_required=False,
            request_has_path_params=True,
            request_has_query_params=True,
            user_agent_header="user-agent",
            accept_header_value="application/json",
            http_headers=http_headers,
            security=utils.get_pydantic_model(
                security, operations.GetApplePayMerchantDomainsSecurity
            ),
            timeout_ms=timeout_ms,
        )

        if retries == UNSET:
            if self.sdk_configuration.retry_config is not UNSET:
                retries = self.sdk_configuration.retry_config

        retry_config = None
        if isinstance(retries, utils.RetryConfig):
            retry_config = (retries, ["429", "500", "502", "503", "504"])

        http_res = await self.do_request_async(
            hook_ctx=HookContext(
                operation_id="getApplePayMerchantDomains",
                oauth2_scopes=[],
                security_source=get_security_from_env(security, components.Security),
            ),
            request=req,
            error_status_codes=["401", "403", "404", "429", "4XX", "500", "504", "5XX"],
            retry_config=retry_config,
        )

        if utils.match_response(http_res, "200", "application/json"):
            return utils.unmarshal_json(
                http_res.text, components.ApplePayMerchantDomains
            )
        if utils.match_response(http_res, ["401", "403", "404", "429", "4XX"], "*"):
            http_res_text = await utils.stream_to_text_async(http_res)
            raise errors.APIError(
                "API error occurred", http_res.status_code, http_res_text, http_res
            )
        if utils.match_response(http_res, ["500", "504", "5XX"], "*"):
            http_res_text = await utils.stream_to_text_async(http_res)
            raise errors.APIError(
                "API error occurred", http_res.status_code, http_res_text, http_res
            )

        content_type = http_res.headers.get("Content-Type")
        http_res_text = await utils.stream_to_text_async(http_res)
        raise errors.APIError(
            f"Unexpected response received (code: {http_res.status_code}, type: {content_type})",
            http_res.status_code,
            http_res_text,
            http_res,
        )

    def create_apple_pay_session(
        self,
        *,
        security: Union[
            operations.CreateApplePaySessionSecurity,
            operations.CreateApplePaySessionSecurityTypedDict,
        ],
        account_id: str,
        domain: str,
        display_name: str,
        x_moov_version: Optional[components.Versions] = None,
        retries: OptionalNullable[utils.RetryConfig] = UNSET,
        server_url: Optional[str] = None,
        timeout_ms: Optional[int] = None,
        http_headers: Optional[Mapping[str, str]] = None,
    ) -> str:
        r"""Create a session with Apple Pay to facilitate a payment.

        Read our [Apple Pay tutorial](https://docs.moov.io/guides/sources/cards/apple-pay/#register-your-domains) to learn more.
        A successful response from this endpoint should be passed through to Apple Pay unchanged.

        To use this endpoint from the browser, you'll need to specify the `/accounts/{accountID}/apple-pay.write` scope when generating
        a [token](https://docs.moov.io/api/authentication/access-tokens/).

        :param security:
        :param account_id: ID of the Moov account representing the merchant.
        :param domain: A fully qualified top-level or sub-domain name where you will accept Apple Pay. Should not include \"https\".
        :param display_name: A UTF-8 string to display in the Buy button.
        :param x_moov_version: Specify an API version.
        :param retries: Override the default retry configuration for this method
        :param server_url: Override the default server URL for this method
        :param timeout_ms: Override the default request timeout configuration for this method in milliseconds
        :param http_headers: Additional headers to set or replace on requests.
        """
        base_url = None
        url_variables = None
        if timeout_ms is None:
            timeout_ms = self.sdk_configuration.timeout_ms

        if server_url is not None:
            base_url = server_url

        request = operations.CreateApplePaySessionRequest(
            x_moov_version=x_moov_version,
            account_id=account_id,
            create_apple_pay_session=components.CreateApplePaySession(
                domain=domain,
                display_name=display_name,
            ),
        )

        req = self._build_request(
            method="POST",
            path="/accounts/{accountID}/apple-pay/sessions",
            base_url=base_url,
            url_variables=url_variables,
            request=request,
            request_body_required=True,
            request_has_path_params=True,
            request_has_query_params=True,
            user_agent_header="user-agent",
            accept_header_value="application/json",
            http_headers=http_headers,
            security=utils.get_pydantic_model(
                security, operations.CreateApplePaySessionSecurity
            ),
            get_serialized_body=lambda: utils.serialize_request_body(
                request.create_apple_pay_session,
                False,
                False,
                "json",
                components.CreateApplePaySession,
            ),
            timeout_ms=timeout_ms,
        )

        if retries == UNSET:
            if self.sdk_configuration.retry_config is not UNSET:
                retries = self.sdk_configuration.retry_config

        retry_config = None
        if isinstance(retries, utils.RetryConfig):
            retry_config = (retries, ["429", "500", "502", "503", "504"])

        http_res = self.do_request(
            hook_ctx=HookContext(
                operation_id="createApplePaySession",
                oauth2_scopes=[],
                security_source=get_security_from_env(security, components.Security),
            ),
            request=req,
            error_status_codes=[
                "400",
                "401",
                "403",
                "404",
                "409",
                "422",
                "429",
                "4XX",
                "500",
                "504",
                "5XX",
            ],
            retry_config=retry_config,
        )

        data: Any = None
        if utils.match_response(http_res, "200", "application/json"):
            return utils.unmarshal_json(http_res.text, str)
        if utils.match_response(http_res, ["400", "409", "422"], "application/json"):
            data = utils.unmarshal_json(http_res.text, errors.GenericErrorData)
            raise errors.GenericError(data=data)
        if utils.match_response(http_res, ["401", "403", "404", "429", "4XX"], "*"):
            http_res_text = utils.stream_to_text(http_res)
            raise errors.APIError(
                "API error occurred", http_res.status_code, http_res_text, http_res
            )
        if utils.match_response(http_res, ["500", "504", "5XX"], "*"):
            http_res_text = utils.stream_to_text(http_res)
            raise errors.APIError(
                "API error occurred", http_res.status_code, http_res_text, http_res
            )

        content_type = http_res.headers.get("Content-Type")
        http_res_text = utils.stream_to_text(http_res)
        raise errors.APIError(
            f"Unexpected response received (code: {http_res.status_code}, type: {content_type})",
            http_res.status_code,
            http_res_text,
            http_res,
        )

    async def create_apple_pay_session_async(
        self,
        *,
        security: Union[
            operations.CreateApplePaySessionSecurity,
            operations.CreateApplePaySessionSecurityTypedDict,
        ],
        account_id: str,
        domain: str,
        display_name: str,
        x_moov_version: Optional[components.Versions] = None,
        retries: OptionalNullable[utils.RetryConfig] = UNSET,
        server_url: Optional[str] = None,
        timeout_ms: Optional[int] = None,
        http_headers: Optional[Mapping[str, str]] = None,
    ) -> str:
        r"""Create a session with Apple Pay to facilitate a payment.

        Read our [Apple Pay tutorial](https://docs.moov.io/guides/sources/cards/apple-pay/#register-your-domains) to learn more.
        A successful response from this endpoint should be passed through to Apple Pay unchanged.

        To use this endpoint from the browser, you'll need to specify the `/accounts/{accountID}/apple-pay.write` scope when generating
        a [token](https://docs.moov.io/api/authentication/access-tokens/).

        :param security:
        :param account_id: ID of the Moov account representing the merchant.
        :param domain: A fully qualified top-level or sub-domain name where you will accept Apple Pay. Should not include \"https\".
        :param display_name: A UTF-8 string to display in the Buy button.
        :param x_moov_version: Specify an API version.
        :param retries: Override the default retry configuration for this method
        :param server_url: Override the default server URL for this method
        :param timeout_ms: Override the default request timeout configuration for this method in milliseconds
        :param http_headers: Additional headers to set or replace on requests.
        """
        base_url = None
        url_variables = None
        if timeout_ms is None:
            timeout_ms = self.sdk_configuration.timeout_ms

        if server_url is not None:
            base_url = server_url

        request = operations.CreateApplePaySessionRequest(
            x_moov_version=x_moov_version,
            account_id=account_id,
            create_apple_pay_session=components.CreateApplePaySession(
                domain=domain,
                display_name=display_name,
            ),
        )

        req = self._build_request_async(
            method="POST",
            path="/accounts/{accountID}/apple-pay/sessions",
            base_url=base_url,
            url_variables=url_variables,
            request=request,
            request_body_required=True,
            request_has_path_params=True,
            request_has_query_params=True,
            user_agent_header="user-agent",
            accept_header_value="application/json",
            http_headers=http_headers,
            security=utils.get_pydantic_model(
                security, operations.CreateApplePaySessionSecurity
            ),
            get_serialized_body=lambda: utils.serialize_request_body(
                request.create_apple_pay_session,
                False,
                False,
                "json",
                components.CreateApplePaySession,
            ),
            timeout_ms=timeout_ms,
        )

        if retries == UNSET:
            if self.sdk_configuration.retry_config is not UNSET:
                retries = self.sdk_configuration.retry_config

        retry_config = None
        if isinstance(retries, utils.RetryConfig):
            retry_config = (retries, ["429", "500", "502", "503", "504"])

        http_res = await self.do_request_async(
            hook_ctx=HookContext(
                operation_id="createApplePaySession",
                oauth2_scopes=[],
                security_source=get_security_from_env(security, components.Security),
            ),
            request=req,
            error_status_codes=[
                "400",
                "401",
                "403",
                "404",
                "409",
                "422",
                "429",
                "4XX",
                "500",
                "504",
                "5XX",
            ],
            retry_config=retry_config,
        )

        data: Any = None
        if utils.match_response(http_res, "200", "application/json"):
            return utils.unmarshal_json(http_res.text, str)
        if utils.match_response(http_res, ["400", "409", "422"], "application/json"):
            data = utils.unmarshal_json(http_res.text, errors.GenericErrorData)
            raise errors.GenericError(data=data)
        if utils.match_response(http_res, ["401", "403", "404", "429", "4XX"], "*"):
            http_res_text = await utils.stream_to_text_async(http_res)
            raise errors.APIError(
                "API error occurred", http_res.status_code, http_res_text, http_res
            )
        if utils.match_response(http_res, ["500", "504", "5XX"], "*"):
            http_res_text = await utils.stream_to_text_async(http_res)
            raise errors.APIError(
                "API error occurred", http_res.status_code, http_res_text, http_res
            )

        content_type = http_res.headers.get("Content-Type")
        http_res_text = await utils.stream_to_text_async(http_res)
        raise errors.APIError(
            f"Unexpected response received (code: {http_res.status_code}, type: {content_type})",
            http_res.status_code,
            http_res_text,
            http_res,
        )

    def link_apple_pay_token(
        self,
        *,
        security: Union[
            operations.LinkApplePayTokenSecurity,
            operations.LinkApplePayTokenSecurityTypedDict,
        ],
        account_id: str,
        token: Union[
            components.LinkApplePayToken, components.LinkApplePayTokenTypedDict
        ],
        x_moov_version: Optional[components.Versions] = None,
        billing_contact: Optional[
            Union[
                components.AppleBillingContact, components.AppleBillingContactTypedDict
            ]
        ] = None,
        retries: OptionalNullable[utils.RetryConfig] = UNSET,
        server_url: Optional[str] = None,
        timeout_ms: Optional[int] = None,
        http_headers: Optional[Mapping[str, str]] = None,
    ) -> components.LinkedApplePayPaymentMethod:
        r"""Connect an Apple Pay token to the specified account.

        Read our [Apple Pay tutorial](https://docs.moov.io/guides/sources/cards/apple-pay/#register-your-domains) to learn more.
        The `token` data is defined by Apple Pay and should be passed through from Apple Pay's response unmodified.

        To use this endpoint from the browser, you'll need to specify the `/accounts/{accountID}/cards.write` scope when generating
        a [token](https://docs.moov.io/api/authentication/access-tokens/).

        :param security:
        :param account_id: ID of the Moov account representing the cardholder.
        :param token: Contains the user's payment information as returned from Apple Pay.    Refer to [Apple's documentation](https://developer.apple.com/documentation/apple_pay_on_the_web/applepaypaymenttoken)    for more information.
        :param x_moov_version: Specify an API version.
        :param billing_contact: Billing contact information as returned from Apple Pay.      Refer to [Apple's documentation](https://developer.apple.com/documentation/apple_pay_on_the_web/applepaypaymentcontact)    for more information.
        :param retries: Override the default retry configuration for this method
        :param server_url: Override the default server URL for this method
        :param timeout_ms: Override the default request timeout configuration for this method in milliseconds
        :param http_headers: Additional headers to set or replace on requests.
        """
        base_url = None
        url_variables = None
        if timeout_ms is None:
            timeout_ms = self.sdk_configuration.timeout_ms

        if server_url is not None:
            base_url = server_url

        request = operations.LinkApplePayTokenRequest(
            x_moov_version=x_moov_version,
            account_id=account_id,
            link_apple_pay=components.LinkApplePay(
                token=utils.get_pydantic_model(token, components.LinkApplePayToken),
                billing_contact=utils.get_pydantic_model(
                    billing_contact, Optional[components.AppleBillingContact]
                ),
            ),
        )

        req = self._build_request(
            method="POST",
            path="/accounts/{accountID}/apple-pay/tokens",
            base_url=base_url,
            url_variables=url_variables,
            request=request,
            request_body_required=True,
            request_has_path_params=True,
            request_has_query_params=True,
            user_agent_header="user-agent",
            accept_header_value="application/json",
            http_headers=http_headers,
            security=utils.get_pydantic_model(
                security, operations.LinkApplePayTokenSecurity
            ),
            get_serialized_body=lambda: utils.serialize_request_body(
                request.link_apple_pay, False, False, "json", components.LinkApplePay
            ),
            timeout_ms=timeout_ms,
        )

        if retries == UNSET:
            if self.sdk_configuration.retry_config is not UNSET:
                retries = self.sdk_configuration.retry_config

        retry_config = None
        if isinstance(retries, utils.RetryConfig):
            retry_config = (retries, ["429", "500", "502", "503", "504"])

        http_res = self.do_request(
            hook_ctx=HookContext(
                operation_id="linkApplePayToken",
                oauth2_scopes=[],
                security_source=get_security_from_env(security, components.Security),
            ),
            request=req,
            error_status_codes=[
                "400",
                "401",
                "403",
                "404",
                "409",
                "422",
                "429",
                "4XX",
                "500",
                "504",
                "5XX",
            ],
            retry_config=retry_config,
        )

        data: Any = None
        if utils.match_response(http_res, "200", "application/json"):
            return utils.unmarshal_json(
                http_res.text, components.LinkedApplePayPaymentMethod
            )
        if utils.match_response(http_res, ["400", "409"], "application/json"):
            data = utils.unmarshal_json(http_res.text, errors.GenericErrorData)
            raise errors.GenericError(data=data)
        if utils.match_response(http_res, ["401", "403", "404", "429", "4XX"], "*"):
            http_res_text = utils.stream_to_text(http_res)
            raise errors.APIError(
                "API error occurred", http_res.status_code, http_res_text, http_res
            )
        if utils.match_response(http_res, "422", "application/json"):
            data = utils.unmarshal_json(http_res.text, errors.LinkApplePayErrorData)
            raise errors.LinkApplePayError(data=data)
        if utils.match_response(http_res, ["500", "504", "5XX"], "*"):
            http_res_text = utils.stream_to_text(http_res)
            raise errors.APIError(
                "API error occurred", http_res.status_code, http_res_text, http_res
            )

        content_type = http_res.headers.get("Content-Type")
        http_res_text = utils.stream_to_text(http_res)
        raise errors.APIError(
            f"Unexpected response received (code: {http_res.status_code}, type: {content_type})",
            http_res.status_code,
            http_res_text,
            http_res,
        )

    async def link_apple_pay_token_async(
        self,
        *,
        security: Union[
            operations.LinkApplePayTokenSecurity,
            operations.LinkApplePayTokenSecurityTypedDict,
        ],
        account_id: str,
        token: Union[
            components.LinkApplePayToken, components.LinkApplePayTokenTypedDict
        ],
        x_moov_version: Optional[components.Versions] = None,
        billing_contact: Optional[
            Union[
                components.AppleBillingContact, components.AppleBillingContactTypedDict
            ]
        ] = None,
        retries: OptionalNullable[utils.RetryConfig] = UNSET,
        server_url: Optional[str] = None,
        timeout_ms: Optional[int] = None,
        http_headers: Optional[Mapping[str, str]] = None,
    ) -> components.LinkedApplePayPaymentMethod:
        r"""Connect an Apple Pay token to the specified account.

        Read our [Apple Pay tutorial](https://docs.moov.io/guides/sources/cards/apple-pay/#register-your-domains) to learn more.
        The `token` data is defined by Apple Pay and should be passed through from Apple Pay's response unmodified.

        To use this endpoint from the browser, you'll need to specify the `/accounts/{accountID}/cards.write` scope when generating
        a [token](https://docs.moov.io/api/authentication/access-tokens/).

        :param security:
        :param account_id: ID of the Moov account representing the cardholder.
        :param token: Contains the user's payment information as returned from Apple Pay.    Refer to [Apple's documentation](https://developer.apple.com/documentation/apple_pay_on_the_web/applepaypaymenttoken)    for more information.
        :param x_moov_version: Specify an API version.
        :param billing_contact: Billing contact information as returned from Apple Pay.      Refer to [Apple's documentation](https://developer.apple.com/documentation/apple_pay_on_the_web/applepaypaymentcontact)    for more information.
        :param retries: Override the default retry configuration for this method
        :param server_url: Override the default server URL for this method
        :param timeout_ms: Override the default request timeout configuration for this method in milliseconds
        :param http_headers: Additional headers to set or replace on requests.
        """
        base_url = None
        url_variables = None
        if timeout_ms is None:
            timeout_ms = self.sdk_configuration.timeout_ms

        if server_url is not None:
            base_url = server_url

        request = operations.LinkApplePayTokenRequest(
            x_moov_version=x_moov_version,
            account_id=account_id,
            link_apple_pay=components.LinkApplePay(
                token=utils.get_pydantic_model(token, components.LinkApplePayToken),
                billing_contact=utils.get_pydantic_model(
                    billing_contact, Optional[components.AppleBillingContact]
                ),
            ),
        )

        req = self._build_request_async(
            method="POST",
            path="/accounts/{accountID}/apple-pay/tokens",
            base_url=base_url,
            url_variables=url_variables,
            request=request,
            request_body_required=True,
            request_has_path_params=True,
            request_has_query_params=True,
            user_agent_header="user-agent",
            accept_header_value="application/json",
            http_headers=http_headers,
            security=utils.get_pydantic_model(
                security, operations.LinkApplePayTokenSecurity
            ),
            get_serialized_body=lambda: utils.serialize_request_body(
                request.link_apple_pay, False, False, "json", components.LinkApplePay
            ),
            timeout_ms=timeout_ms,
        )

        if retries == UNSET:
            if self.sdk_configuration.retry_config is not UNSET:
                retries = self.sdk_configuration.retry_config

        retry_config = None
        if isinstance(retries, utils.RetryConfig):
            retry_config = (retries, ["429", "500", "502", "503", "504"])

        http_res = await self.do_request_async(
            hook_ctx=HookContext(
                operation_id="linkApplePayToken",
                oauth2_scopes=[],
                security_source=get_security_from_env(security, components.Security),
            ),
            request=req,
            error_status_codes=[
                "400",
                "401",
                "403",
                "404",
                "409",
                "422",
                "429",
                "4XX",
                "500",
                "504",
                "5XX",
            ],
            retry_config=retry_config,
        )

        data: Any = None
        if utils.match_response(http_res, "200", "application/json"):
            return utils.unmarshal_json(
                http_res.text, components.LinkedApplePayPaymentMethod
            )
        if utils.match_response(http_res, ["400", "409"], "application/json"):
            data = utils.unmarshal_json(http_res.text, errors.GenericErrorData)
            raise errors.GenericError(data=data)
        if utils.match_response(http_res, ["401", "403", "404", "429", "4XX"], "*"):
            http_res_text = await utils.stream_to_text_async(http_res)
            raise errors.APIError(
                "API error occurred", http_res.status_code, http_res_text, http_res
            )
        if utils.match_response(http_res, "422", "application/json"):
            data = utils.unmarshal_json(http_res.text, errors.LinkApplePayErrorData)
            raise errors.LinkApplePayError(data=data)
        if utils.match_response(http_res, ["500", "504", "5XX"], "*"):
            http_res_text = await utils.stream_to_text_async(http_res)
            raise errors.APIError(
                "API error occurred", http_res.status_code, http_res_text, http_res
            )

        content_type = http_res.headers.get("Content-Type")
        http_res_text = await utils.stream_to_text_async(http_res)
        raise errors.APIError(
            f"Unexpected response received (code: {http_res.status_code}, type: {content_type})",
            http_res.status_code,
            http_res_text,
            http_res,
        )

    def link_card(
        self,
        *,
        security: Union[
            operations.LinkCardSecurity, operations.LinkCardSecurityTypedDict
        ],
        account_id: str,
        card_number: str,
        card_cvv: str,
        expiration: Union[
            components.CardExpiration, components.CardExpirationTypedDict
        ],
        billing_address: Union[components.CardAddress, components.CardAddressTypedDict],
        x_moov_version: Optional[components.Versions] = None,
        x_wait_for: Optional[components.LinkCardWaitFor] = None,
        e2ee: Optional[
            Union[components.E2EEToken, components.E2EETokenTypedDict]
        ] = None,
        holder_name: Optional[str] = None,
        card_on_file: Optional[bool] = None,
        merchant_account_id: Optional[str] = None,
        verify_name: Optional[bool] = None,
        retries: OptionalNullable[utils.RetryConfig] = UNSET,
        server_url: Optional[str] = None,
        timeout_ms: Optional[int] = None,
        http_headers: Optional[Mapping[str, str]] = None,
    ) -> components.Card:
        r"""Link a card to an existing Moov account.

        Read our [accept card payments guide](https://docs.moov.io/guides/sources/cards/accept-card-payments/#link-a-card) to learn more.

        Only use this endpoint if you have provided Moov with a copy of your PCI attestation of compliance.

        During card linking, the provided data will be verified by submitting a $0 authorization (account verification) request.
        If `merchantAccountID` is provided, the authorization request will contain that account's statement descriptor and address.
        Otherwise, the platform account's profile will be used. If no statement descriptor has been set, the authorization will
        use the account's name instead.

        It is strongly recommended that callers include the `X-Wait-For` header, set to `payment-method`, if the newly linked
        card is intended to be used right away. If this header is not included, the caller will need to poll the [List Payment
        Methods](https://docs.moov.io/api/sources/payment-methods/list/)
        endpoint to wait for the new payment methods to be available for use.

        To use this endpoint from the browser, you'll need to specify the `/accounts/{accountID}/cards.write` scope
        when generating a [token](https://docs.moov.io/api/authentication/access-tokens/).

        :param security:
        :param account_id:
        :param card_number:
        :param card_cvv:
        :param expiration: The expiration date of the card or token.
        :param billing_address:
        :param x_moov_version: Specify an API version.
        :param x_wait_for: Optional header to wait for certain events, such as the creation of a payment method, to occur before returning a response.  When this header is set to `payment-method`, the response will include any payment methods that were created for the newly  linked card in the `paymentMethods` field. Otherwise, the `paymentMethods` field will be omitted from the response.
        :param e2ee: Wraps a compact-serialized JSON Web Encryption (JWE) token used for secure transmission of sensitive data (e.g., PCI information) through intermediaries.  This token is encrypted using the public key from /end-to-end-keys and wraps an AES key. For details and examples, refer to our  [GitHub repository](https://github.com/moovfinancial/moov-go/blob/main/examples/e2ee/e2ee_test.go).
        :param holder_name:
        :param card_on_file:
        :param merchant_account_id:
        :param verify_name:
        :param retries: Override the default retry configuration for this method
        :param server_url: Override the default server URL for this method
        :param timeout_ms: Override the default request timeout configuration for this method in milliseconds
        :param http_headers: Additional headers to set or replace on requests.
        """
        base_url = None
        url_variables = None
        if timeout_ms is None:
            timeout_ms = self.sdk_configuration.timeout_ms

        if server_url is not None:
            base_url = server_url

        request = operations.LinkCardRequest(
            x_moov_version=x_moov_version,
            x_wait_for=x_wait_for,
            account_id=account_id,
            link_card=components.LinkCard(
                e2ee=utils.get_pydantic_model(e2ee, Optional[components.E2EEToken]),
                card_number=card_number,
                card_cvv=card_cvv,
                expiration=utils.get_pydantic_model(
                    expiration, components.CardExpiration
                ),
                holder_name=holder_name,
                billing_address=utils.get_pydantic_model(
                    billing_address, components.CardAddress
                ),
                card_on_file=card_on_file,
                merchant_account_id=merchant_account_id,
                verify_name=verify_name,
            ),
        )

        req = self._build_request(
            method="POST",
            path="/accounts/{accountID}/cards",
            base_url=base_url,
            url_variables=url_variables,
            request=request,
            request_body_required=True,
            request_has_path_params=True,
            request_has_query_params=True,
            user_agent_header="user-agent",
            accept_header_value="application/json",
            http_headers=http_headers,
            security=utils.get_pydantic_model(security, operations.LinkCardSecurity),
            get_serialized_body=lambda: utils.serialize_request_body(
                request.link_card, False, False, "json", components.LinkCard
            ),
            timeout_ms=timeout_ms,
        )

        if retries == UNSET:
            if self.sdk_configuration.retry_config is not UNSET:
                retries = self.sdk_configuration.retry_config

        retry_config = None
        if isinstance(retries, utils.RetryConfig):
            retry_config = (retries, ["429", "500", "502", "503", "504"])

        http_res = self.do_request(
            hook_ctx=HookContext(
                operation_id="linkCard",
                oauth2_scopes=[],
                security_source=get_security_from_env(security, components.Security),
            ),
            request=req,
            error_status_codes=[
                "400",
                "401",
                "403",
                "404",
                "409",
                "422",
                "429",
                "4XX",
                "500",
                "504",
                "5XX",
            ],
            retry_config=retry_config,
        )

        data: Any = None
        if utils.match_response(http_res, "200", "application/json"):
            return utils.unmarshal_json(http_res.text, components.Card)
        if utils.match_response(http_res, ["400", "409"], "application/json"):
            data = utils.unmarshal_json(http_res.text, errors.GenericErrorData)
            raise errors.GenericError(data=data)
        if utils.match_response(http_res, ["401", "403", "404", "429", "4XX"], "*"):
            http_res_text = utils.stream_to_text(http_res)
            raise errors.APIError(
                "API error occurred", http_res.status_code, http_res_text, http_res
            )
        if utils.match_response(http_res, "422", "application/json"):
            data = utils.unmarshal_json(http_res.text, errors.LinkCardErrorData)
            raise errors.LinkCardError(data=data)
        if utils.match_response(http_res, ["500", "504", "5XX"], "*"):
            http_res_text = utils.stream_to_text(http_res)
            raise errors.APIError(
                "API error occurred", http_res.status_code, http_res_text, http_res
            )

        content_type = http_res.headers.get("Content-Type")
        http_res_text = utils.stream_to_text(http_res)
        raise errors.APIError(
            f"Unexpected response received (code: {http_res.status_code}, type: {content_type})",
            http_res.status_code,
            http_res_text,
            http_res,
        )

    async def link_card_async(
        self,
        *,
        security: Union[
            operations.LinkCardSecurity, operations.LinkCardSecurityTypedDict
        ],
        account_id: str,
        card_number: str,
        card_cvv: str,
        expiration: Union[
            components.CardExpiration, components.CardExpirationTypedDict
        ],
        billing_address: Union[components.CardAddress, components.CardAddressTypedDict],
        x_moov_version: Optional[components.Versions] = None,
        x_wait_for: Optional[components.LinkCardWaitFor] = None,
        e2ee: Optional[
            Union[components.E2EEToken, components.E2EETokenTypedDict]
        ] = None,
        holder_name: Optional[str] = None,
        card_on_file: Optional[bool] = None,
        merchant_account_id: Optional[str] = None,
        verify_name: Optional[bool] = None,
        retries: OptionalNullable[utils.RetryConfig] = UNSET,
        server_url: Optional[str] = None,
        timeout_ms: Optional[int] = None,
        http_headers: Optional[Mapping[str, str]] = None,
    ) -> components.Card:
        r"""Link a card to an existing Moov account.

        Read our [accept card payments guide](https://docs.moov.io/guides/sources/cards/accept-card-payments/#link-a-card) to learn more.

        Only use this endpoint if you have provided Moov with a copy of your PCI attestation of compliance.

        During card linking, the provided data will be verified by submitting a $0 authorization (account verification) request.
        If `merchantAccountID` is provided, the authorization request will contain that account's statement descriptor and address.
        Otherwise, the platform account's profile will be used. If no statement descriptor has been set, the authorization will
        use the account's name instead.

        It is strongly recommended that callers include the `X-Wait-For` header, set to `payment-method`, if the newly linked
        card is intended to be used right away. If this header is not included, the caller will need to poll the [List Payment
        Methods](https://docs.moov.io/api/sources/payment-methods/list/)
        endpoint to wait for the new payment methods to be available for use.

        To use this endpoint from the browser, you'll need to specify the `/accounts/{accountID}/cards.write` scope
        when generating a [token](https://docs.moov.io/api/authentication/access-tokens/).

        :param security:
        :param account_id:
        :param card_number:
        :param card_cvv:
        :param expiration: The expiration date of the card or token.
        :param billing_address:
        :param x_moov_version: Specify an API version.
        :param x_wait_for: Optional header to wait for certain events, such as the creation of a payment method, to occur before returning a response.  When this header is set to `payment-method`, the response will include any payment methods that were created for the newly  linked card in the `paymentMethods` field. Otherwise, the `paymentMethods` field will be omitted from the response.
        :param e2ee: Wraps a compact-serialized JSON Web Encryption (JWE) token used for secure transmission of sensitive data (e.g., PCI information) through intermediaries.  This token is encrypted using the public key from /end-to-end-keys and wraps an AES key. For details and examples, refer to our  [GitHub repository](https://github.com/moovfinancial/moov-go/blob/main/examples/e2ee/e2ee_test.go).
        :param holder_name:
        :param card_on_file:
        :param merchant_account_id:
        :param verify_name:
        :param retries: Override the default retry configuration for this method
        :param server_url: Override the default server URL for this method
        :param timeout_ms: Override the default request timeout configuration for this method in milliseconds
        :param http_headers: Additional headers to set or replace on requests.
        """
        base_url = None
        url_variables = None
        if timeout_ms is None:
            timeout_ms = self.sdk_configuration.timeout_ms

        if server_url is not None:
            base_url = server_url

        request = operations.LinkCardRequest(
            x_moov_version=x_moov_version,
            x_wait_for=x_wait_for,
            account_id=account_id,
            link_card=components.LinkCard(
                e2ee=utils.get_pydantic_model(e2ee, Optional[components.E2EEToken]),
                card_number=card_number,
                card_cvv=card_cvv,
                expiration=utils.get_pydantic_model(
                    expiration, components.CardExpiration
                ),
                holder_name=holder_name,
                billing_address=utils.get_pydantic_model(
                    billing_address, components.CardAddress
                ),
                card_on_file=card_on_file,
                merchant_account_id=merchant_account_id,
                verify_name=verify_name,
            ),
        )

        req = self._build_request_async(
            method="POST",
            path="/accounts/{accountID}/cards",
            base_url=base_url,
            url_variables=url_variables,
            request=request,
            request_body_required=True,
            request_has_path_params=True,
            request_has_query_params=True,
            user_agent_header="user-agent",
            accept_header_value="application/json",
            http_headers=http_headers,
            security=utils.get_pydantic_model(security, operations.LinkCardSecurity),
            get_serialized_body=lambda: utils.serialize_request_body(
                request.link_card, False, False, "json", components.LinkCard
            ),
            timeout_ms=timeout_ms,
        )

        if retries == UNSET:
            if self.sdk_configuration.retry_config is not UNSET:
                retries = self.sdk_configuration.retry_config

        retry_config = None
        if isinstance(retries, utils.RetryConfig):
            retry_config = (retries, ["429", "500", "502", "503", "504"])

        http_res = await self.do_request_async(
            hook_ctx=HookContext(
                operation_id="linkCard",
                oauth2_scopes=[],
                security_source=get_security_from_env(security, components.Security),
            ),
            request=req,
            error_status_codes=[
                "400",
                "401",
                "403",
                "404",
                "409",
                "422",
                "429",
                "4XX",
                "500",
                "504",
                "5XX",
            ],
            retry_config=retry_config,
        )

        data: Any = None
        if utils.match_response(http_res, "200", "application/json"):
            return utils.unmarshal_json(http_res.text, components.Card)
        if utils.match_response(http_res, ["400", "409"], "application/json"):
            data = utils.unmarshal_json(http_res.text, errors.GenericErrorData)
            raise errors.GenericError(data=data)
        if utils.match_response(http_res, ["401", "403", "404", "429", "4XX"], "*"):
            http_res_text = await utils.stream_to_text_async(http_res)
            raise errors.APIError(
                "API error occurred", http_res.status_code, http_res_text, http_res
            )
        if utils.match_response(http_res, "422", "application/json"):
            data = utils.unmarshal_json(http_res.text, errors.LinkCardErrorData)
            raise errors.LinkCardError(data=data)
        if utils.match_response(http_res, ["500", "504", "5XX"], "*"):
            http_res_text = await utils.stream_to_text_async(http_res)
            raise errors.APIError(
                "API error occurred", http_res.status_code, http_res_text, http_res
            )

        content_type = http_res.headers.get("Content-Type")
        http_res_text = await utils.stream_to_text_async(http_res)
        raise errors.APIError(
            f"Unexpected response received (code: {http_res.status_code}, type: {content_type})",
            http_res.status_code,
            http_res_text,
            http_res,
        )

    def list_cards(
        self,
        *,
        security: Union[
            operations.ListCardsSecurity, operations.ListCardsSecurityTypedDict
        ],
        account_id: str,
        x_moov_version: Optional[components.Versions] = None,
        retries: OptionalNullable[utils.RetryConfig] = UNSET,
        server_url: Optional[str] = None,
        timeout_ms: Optional[int] = None,
        http_headers: Optional[Mapping[str, str]] = None,
    ) -> List[components.Card]:
        r"""List all the active cards associated with a Moov account.

        Read our [accept card payments guide](https://docs.moov.io/guides/sources/cards/accept-card-payments/) to learn more.

        To use this endpoint from the browser, you'll need to specify the `/accounts/{accountID}/cards.read` scope when generating
        a [token](https://docs.moov.io/api/authentication/access-tokens/).

        :param security:
        :param account_id:
        :param x_moov_version: Specify an API version.
        :param retries: Override the default retry configuration for this method
        :param server_url: Override the default server URL for this method
        :param timeout_ms: Override the default request timeout configuration for this method in milliseconds
        :param http_headers: Additional headers to set or replace on requests.
        """
        base_url = None
        url_variables = None
        if timeout_ms is None:
            timeout_ms = self.sdk_configuration.timeout_ms

        if server_url is not None:
            base_url = server_url

        request = operations.ListCardsRequest(
            x_moov_version=x_moov_version,
            account_id=account_id,
        )

        req = self._build_request(
            method="GET",
            path="/accounts/{accountID}/cards",
            base_url=base_url,
            url_variables=url_variables,
            request=request,
            request_body_required=False,
            request_has_path_params=True,
            request_has_query_params=True,
            user_agent_header="user-agent",
            accept_header_value="application/json",
            http_headers=http_headers,
            security=utils.get_pydantic_model(security, operations.ListCardsSecurity),
            timeout_ms=timeout_ms,
        )

        if retries == UNSET:
            if self.sdk_configuration.retry_config is not UNSET:
                retries = self.sdk_configuration.retry_config

        retry_config = None
        if isinstance(retries, utils.RetryConfig):
            retry_config = (retries, ["429", "500", "502", "503", "504"])

        http_res = self.do_request(
            hook_ctx=HookContext(
                operation_id="listCards",
                oauth2_scopes=[],
                security_source=get_security_from_env(security, components.Security),
            ),
            request=req,
            error_status_codes=["401", "403", "429", "4XX", "500", "504", "5XX"],
            retry_config=retry_config,
        )

        if utils.match_response(http_res, "200", "application/json"):
            return utils.unmarshal_json(http_res.text, List[components.Card])
        if utils.match_response(http_res, ["401", "403", "429", "4XX"], "*"):
            http_res_text = utils.stream_to_text(http_res)
            raise errors.APIError(
                "API error occurred", http_res.status_code, http_res_text, http_res
            )
        if utils.match_response(http_res, ["500", "504", "5XX"], "*"):
            http_res_text = utils.stream_to_text(http_res)
            raise errors.APIError(
                "API error occurred", http_res.status_code, http_res_text, http_res
            )

        content_type = http_res.headers.get("Content-Type")
        http_res_text = utils.stream_to_text(http_res)
        raise errors.APIError(
            f"Unexpected response received (code: {http_res.status_code}, type: {content_type})",
            http_res.status_code,
            http_res_text,
            http_res,
        )

    async def list_cards_async(
        self,
        *,
        security: Union[
            operations.ListCardsSecurity, operations.ListCardsSecurityTypedDict
        ],
        account_id: str,
        x_moov_version: Optional[components.Versions] = None,
        retries: OptionalNullable[utils.RetryConfig] = UNSET,
        server_url: Optional[str] = None,
        timeout_ms: Optional[int] = None,
        http_headers: Optional[Mapping[str, str]] = None,
    ) -> List[components.Card]:
        r"""List all the active cards associated with a Moov account.

        Read our [accept card payments guide](https://docs.moov.io/guides/sources/cards/accept-card-payments/) to learn more.

        To use this endpoint from the browser, you'll need to specify the `/accounts/{accountID}/cards.read` scope when generating
        a [token](https://docs.moov.io/api/authentication/access-tokens/).

        :param security:
        :param account_id:
        :param x_moov_version: Specify an API version.
        :param retries: Override the default retry configuration for this method
        :param server_url: Override the default server URL for this method
        :param timeout_ms: Override the default request timeout configuration for this method in milliseconds
        :param http_headers: Additional headers to set or replace on requests.
        """
        base_url = None
        url_variables = None
        if timeout_ms is None:
            timeout_ms = self.sdk_configuration.timeout_ms

        if server_url is not None:
            base_url = server_url

        request = operations.ListCardsRequest(
            x_moov_version=x_moov_version,
            account_id=account_id,
        )

        req = self._build_request_async(
            method="GET",
            path="/accounts/{accountID}/cards",
            base_url=base_url,
            url_variables=url_variables,
            request=request,
            request_body_required=False,
            request_has_path_params=True,
            request_has_query_params=True,
            user_agent_header="user-agent",
            accept_header_value="application/json",
            http_headers=http_headers,
            security=utils.get_pydantic_model(security, operations.ListCardsSecurity),
            timeout_ms=timeout_ms,
        )

        if retries == UNSET:
            if self.sdk_configuration.retry_config is not UNSET:
                retries = self.sdk_configuration.retry_config

        retry_config = None
        if isinstance(retries, utils.RetryConfig):
            retry_config = (retries, ["429", "500", "502", "503", "504"])

        http_res = await self.do_request_async(
            hook_ctx=HookContext(
                operation_id="listCards",
                oauth2_scopes=[],
                security_source=get_security_from_env(security, components.Security),
            ),
            request=req,
            error_status_codes=["401", "403", "429", "4XX", "500", "504", "5XX"],
            retry_config=retry_config,
        )

        if utils.match_response(http_res, "200", "application/json"):
            return utils.unmarshal_json(http_res.text, List[components.Card])
        if utils.match_response(http_res, ["401", "403", "429", "4XX"], "*"):
            http_res_text = await utils.stream_to_text_async(http_res)
            raise errors.APIError(
                "API error occurred", http_res.status_code, http_res_text, http_res
            )
        if utils.match_response(http_res, ["500", "504", "5XX"], "*"):
            http_res_text = await utils.stream_to_text_async(http_res)
            raise errors.APIError(
                "API error occurred", http_res.status_code, http_res_text, http_res
            )

        content_type = http_res.headers.get("Content-Type")
        http_res_text = await utils.stream_to_text_async(http_res)
        raise errors.APIError(
            f"Unexpected response received (code: {http_res.status_code}, type: {content_type})",
            http_res.status_code,
            http_res_text,
            http_res,
        )

    def get_card(
        self,
        *,
        security: Union[
            operations.GetCardSecurity, operations.GetCardSecurityTypedDict
        ],
        account_id: str,
        card_id: str,
        x_moov_version: Optional[components.Versions] = None,
        retries: OptionalNullable[utils.RetryConfig] = UNSET,
        server_url: Optional[str] = None,
        timeout_ms: Optional[int] = None,
        http_headers: Optional[Mapping[str, str]] = None,
    ) -> components.Card:
        r"""Fetch a specific card associated with a Moov account.

        Read our [accept card payments guide](https://docs.moov.io/guides/sources/cards/accept-card-payments/) to learn more.

        To use this endpoint from the browser, you'll need to specify the `/accounts/{accountID}/cards.read` scope when generating
        a [token](https://docs.moov.io/api/authentication/access-tokens/).

        :param security:
        :param account_id:
        :param card_id:
        :param x_moov_version: Specify an API version.
        :param retries: Override the default retry configuration for this method
        :param server_url: Override the default server URL for this method
        :param timeout_ms: Override the default request timeout configuration for this method in milliseconds
        :param http_headers: Additional headers to set or replace on requests.
        """
        base_url = None
        url_variables = None
        if timeout_ms is None:
            timeout_ms = self.sdk_configuration.timeout_ms

        if server_url is not None:
            base_url = server_url

        request = operations.GetCardRequest(
            x_moov_version=x_moov_version,
            account_id=account_id,
            card_id=card_id,
        )

        req = self._build_request(
            method="GET",
            path="/accounts/{accountID}/cards/{cardID}",
            base_url=base_url,
            url_variables=url_variables,
            request=request,
            request_body_required=False,
            request_has_path_params=True,
            request_has_query_params=True,
            user_agent_header="user-agent",
            accept_header_value="application/json",
            http_headers=http_headers,
            security=utils.get_pydantic_model(security, operations.GetCardSecurity),
            timeout_ms=timeout_ms,
        )

        if retries == UNSET:
            if self.sdk_configuration.retry_config is not UNSET:
                retries = self.sdk_configuration.retry_config

        retry_config = None
        if isinstance(retries, utils.RetryConfig):
            retry_config = (retries, ["429", "500", "502", "503", "504"])

        http_res = self.do_request(
            hook_ctx=HookContext(
                operation_id="getCard",
                oauth2_scopes=[],
                security_source=get_security_from_env(security, components.Security),
            ),
            request=req,
            error_status_codes=["401", "403", "404", "429", "4XX", "500", "504", "5XX"],
            retry_config=retry_config,
        )

        if utils.match_response(http_res, "200", "application/json"):
            return utils.unmarshal_json(http_res.text, components.Card)
        if utils.match_response(http_res, ["401", "403", "404", "429", "4XX"], "*"):
            http_res_text = utils.stream_to_text(http_res)
            raise errors.APIError(
                "API error occurred", http_res.status_code, http_res_text, http_res
            )
        if utils.match_response(http_res, ["500", "504", "5XX"], "*"):
            http_res_text = utils.stream_to_text(http_res)
            raise errors.APIError(
                "API error occurred", http_res.status_code, http_res_text, http_res
            )

        content_type = http_res.headers.get("Content-Type")
        http_res_text = utils.stream_to_text(http_res)
        raise errors.APIError(
            f"Unexpected response received (code: {http_res.status_code}, type: {content_type})",
            http_res.status_code,
            http_res_text,
            http_res,
        )

    async def get_card_async(
        self,
        *,
        security: Union[
            operations.GetCardSecurity, operations.GetCardSecurityTypedDict
        ],
        account_id: str,
        card_id: str,
        x_moov_version: Optional[components.Versions] = None,
        retries: OptionalNullable[utils.RetryConfig] = UNSET,
        server_url: Optional[str] = None,
        timeout_ms: Optional[int] = None,
        http_headers: Optional[Mapping[str, str]] = None,
    ) -> components.Card:
        r"""Fetch a specific card associated with a Moov account.

        Read our [accept card payments guide](https://docs.moov.io/guides/sources/cards/accept-card-payments/) to learn more.

        To use this endpoint from the browser, you'll need to specify the `/accounts/{accountID}/cards.read` scope when generating
        a [token](https://docs.moov.io/api/authentication/access-tokens/).

        :param security:
        :param account_id:
        :param card_id:
        :param x_moov_version: Specify an API version.
        :param retries: Override the default retry configuration for this method
        :param server_url: Override the default server URL for this method
        :param timeout_ms: Override the default request timeout configuration for this method in milliseconds
        :param http_headers: Additional headers to set or replace on requests.
        """
        base_url = None
        url_variables = None
        if timeout_ms is None:
            timeout_ms = self.sdk_configuration.timeout_ms

        if server_url is not None:
            base_url = server_url

        request = operations.GetCardRequest(
            x_moov_version=x_moov_version,
            account_id=account_id,
            card_id=card_id,
        )

        req = self._build_request_async(
            method="GET",
            path="/accounts/{accountID}/cards/{cardID}",
            base_url=base_url,
            url_variables=url_variables,
            request=request,
            request_body_required=False,
            request_has_path_params=True,
            request_has_query_params=True,
            user_agent_header="user-agent",
            accept_header_value="application/json",
            http_headers=http_headers,
            security=utils.get_pydantic_model(security, operations.GetCardSecurity),
            timeout_ms=timeout_ms,
        )

        if retries == UNSET:
            if self.sdk_configuration.retry_config is not UNSET:
                retries = self.sdk_configuration.retry_config

        retry_config = None
        if isinstance(retries, utils.RetryConfig):
            retry_config = (retries, ["429", "500", "502", "503", "504"])

        http_res = await self.do_request_async(
            hook_ctx=HookContext(
                operation_id="getCard",
                oauth2_scopes=[],
                security_source=get_security_from_env(security, components.Security),
            ),
            request=req,
            error_status_codes=["401", "403", "404", "429", "4XX", "500", "504", "5XX"],
            retry_config=retry_config,
        )

        if utils.match_response(http_res, "200", "application/json"):
            return utils.unmarshal_json(http_res.text, components.Card)
        if utils.match_response(http_res, ["401", "403", "404", "429", "4XX"], "*"):
            http_res_text = await utils.stream_to_text_async(http_res)
            raise errors.APIError(
                "API error occurred", http_res.status_code, http_res_text, http_res
            )
        if utils.match_response(http_res, ["500", "504", "5XX"], "*"):
            http_res_text = await utils.stream_to_text_async(http_res)
            raise errors.APIError(
                "API error occurred", http_res.status_code, http_res_text, http_res
            )

        content_type = http_res.headers.get("Content-Type")
        http_res_text = await utils.stream_to_text_async(http_res)
        raise errors.APIError(
            f"Unexpected response received (code: {http_res.status_code}, type: {content_type})",
            http_res.status_code,
            http_res_text,
            http_res,
        )

    def update_card(
        self,
        *,
        security: Union[
            operations.UpdateCardSecurity, operations.UpdateCardSecurityTypedDict
        ],
        account_id: str,
        card_id: str,
        x_moov_version: Optional[components.Versions] = None,
        e2ee: Optional[
            Union[components.E2EETokenUpdate, components.E2EETokenUpdateTypedDict]
        ] = None,
        billing_address: Optional[
            Union[components.UpdateCardAddress, components.UpdateCardAddressTypedDict]
        ] = None,
        expiration: Optional[
            Union[
                components.UpdateCardExpiration,
                components.UpdateCardExpirationTypedDict,
            ]
        ] = None,
        card_cvv: Optional[str] = None,
        card_on_file: Optional[bool] = None,
        merchant_account_id: Optional[str] = None,
        verify_name: Optional[bool] = None,
        holder_name: Optional[str] = None,
        retries: OptionalNullable[utils.RetryConfig] = UNSET,
        server_url: Optional[str] = None,
        timeout_ms: Optional[int] = None,
        http_headers: Optional[Mapping[str, str]] = None,
    ) -> components.Card:
        r"""Update a linked card and/or resubmit it for verification.

        If a value is provided for CVV, a new verification ($0 authorization) will be submitted for the card. Updating the expiration
        date or
        address will update the information stored on file for the card but will not be verified.

        Read our [accept card payments guide](https://docs.moov.io/guides/sources/cards/accept-card-payments/#reverify-a-card) to learn
        more.

        Only use this endpoint if you have provided Moov with a copy of your PCI attestation of compliance.

        To use this endpoint from the browser, you'll need to specify the `/accounts/{accountID}/cards.write` scope when generating
        a [token](https://docs.moov.io/api/authentication/access-tokens/).

        :param security:
        :param account_id:
        :param card_id:
        :param x_moov_version: Specify an API version.
        :param e2ee: Wraps a compact-serialized JSON Web Encryption (JWE) token used for secure transmission of sensitive data (e.g., PCI information) through intermediaries.  This token is encrypted using the public key from /end-to-end-keys and wraps an AES key. For details and examples, refer to our  [GitHub repository](https://github.com/moovfinancial/moov-go/blob/main/examples/e2ee/e2ee_test.go).
        :param billing_address:
        :param expiration:
        :param card_cvv:
        :param card_on_file:
        :param merchant_account_id:
        :param verify_name:
        :param holder_name:
        :param retries: Override the default retry configuration for this method
        :param server_url: Override the default server URL for this method
        :param timeout_ms: Override the default request timeout configuration for this method in milliseconds
        :param http_headers: Additional headers to set or replace on requests.
        """
        base_url = None
        url_variables = None
        if timeout_ms is None:
            timeout_ms = self.sdk_configuration.timeout_ms

        if server_url is not None:
            base_url = server_url

        request = operations.UpdateCardRequest(
            x_moov_version=x_moov_version,
            account_id=account_id,
            card_id=card_id,
            update_card=components.UpdateCard(
                e2ee=utils.get_pydantic_model(
                    e2ee, Optional[components.E2EETokenUpdate]
                ),
                billing_address=utils.get_pydantic_model(
                    billing_address, Optional[components.UpdateCardAddress]
                ),
                expiration=utils.get_pydantic_model(
                    expiration, Optional[components.UpdateCardExpiration]
                ),
                card_cvv=card_cvv,
                card_on_file=card_on_file,
                merchant_account_id=merchant_account_id,
                verify_name=verify_name,
                holder_name=holder_name,
            ),
        )

        req = self._build_request(
            method="PATCH",
            path="/accounts/{accountID}/cards/{cardID}",
            base_url=base_url,
            url_variables=url_variables,
            request=request,
            request_body_required=True,
            request_has_path_params=True,
            request_has_query_params=True,
            user_agent_header="user-agent",
            accept_header_value="application/json",
            http_headers=http_headers,
            security=utils.get_pydantic_model(security, operations.UpdateCardSecurity),
            get_serialized_body=lambda: utils.serialize_request_body(
                request.update_card, False, False, "json", components.UpdateCard
            ),
            timeout_ms=timeout_ms,
        )

        if retries == UNSET:
            if self.sdk_configuration.retry_config is not UNSET:
                retries = self.sdk_configuration.retry_config

        retry_config = None
        if isinstance(retries, utils.RetryConfig):
            retry_config = (retries, ["429", "500", "502", "503", "504"])

        http_res = self.do_request(
            hook_ctx=HookContext(
                operation_id="updateCard",
                oauth2_scopes=[],
                security_source=get_security_from_env(security, components.Security),
            ),
            request=req,
            error_status_codes=[
                "400",
                "401",
                "403",
                "404",
                "409",
                "422",
                "429",
                "4XX",
                "500",
                "504",
                "5XX",
            ],
            retry_config=retry_config,
        )

        data: Any = None
        if utils.match_response(http_res, "200", "application/json"):
            return utils.unmarshal_json(http_res.text, components.Card)
        if utils.match_response(http_res, ["400", "409"], "application/json"):
            data = utils.unmarshal_json(http_res.text, errors.GenericErrorData)
            raise errors.GenericError(data=data)
        if utils.match_response(http_res, ["401", "403", "404", "429", "4XX"], "*"):
            http_res_text = utils.stream_to_text(http_res)
            raise errors.APIError(
                "API error occurred", http_res.status_code, http_res_text, http_res
            )
        if utils.match_response(http_res, "422", "application/json"):
            data = utils.unmarshal_json(http_res.text, errors.UpdateCardErrorData)
            raise errors.UpdateCardError(data=data)
        if utils.match_response(http_res, ["500", "504", "5XX"], "*"):
            http_res_text = utils.stream_to_text(http_res)
            raise errors.APIError(
                "API error occurred", http_res.status_code, http_res_text, http_res
            )

        content_type = http_res.headers.get("Content-Type")
        http_res_text = utils.stream_to_text(http_res)
        raise errors.APIError(
            f"Unexpected response received (code: {http_res.status_code}, type: {content_type})",
            http_res.status_code,
            http_res_text,
            http_res,
        )

    async def update_card_async(
        self,
        *,
        security: Union[
            operations.UpdateCardSecurity, operations.UpdateCardSecurityTypedDict
        ],
        account_id: str,
        card_id: str,
        x_moov_version: Optional[components.Versions] = None,
        e2ee: Optional[
            Union[components.E2EETokenUpdate, components.E2EETokenUpdateTypedDict]
        ] = None,
        billing_address: Optional[
            Union[components.UpdateCardAddress, components.UpdateCardAddressTypedDict]
        ] = None,
        expiration: Optional[
            Union[
                components.UpdateCardExpiration,
                components.UpdateCardExpirationTypedDict,
            ]
        ] = None,
        card_cvv: Optional[str] = None,
        card_on_file: Optional[bool] = None,
        merchant_account_id: Optional[str] = None,
        verify_name: Optional[bool] = None,
        holder_name: Optional[str] = None,
        retries: OptionalNullable[utils.RetryConfig] = UNSET,
        server_url: Optional[str] = None,
        timeout_ms: Optional[int] = None,
        http_headers: Optional[Mapping[str, str]] = None,
    ) -> components.Card:
        r"""Update a linked card and/or resubmit it for verification.

        If a value is provided for CVV, a new verification ($0 authorization) will be submitted for the card. Updating the expiration
        date or
        address will update the information stored on file for the card but will not be verified.

        Read our [accept card payments guide](https://docs.moov.io/guides/sources/cards/accept-card-payments/#reverify-a-card) to learn
        more.

        Only use this endpoint if you have provided Moov with a copy of your PCI attestation of compliance.

        To use this endpoint from the browser, you'll need to specify the `/accounts/{accountID}/cards.write` scope when generating
        a [token](https://docs.moov.io/api/authentication/access-tokens/).

        :param security:
        :param account_id:
        :param card_id:
        :param x_moov_version: Specify an API version.
        :param e2ee: Wraps a compact-serialized JSON Web Encryption (JWE) token used for secure transmission of sensitive data (e.g., PCI information) through intermediaries.  This token is encrypted using the public key from /end-to-end-keys and wraps an AES key. For details and examples, refer to our  [GitHub repository](https://github.com/moovfinancial/moov-go/blob/main/examples/e2ee/e2ee_test.go).
        :param billing_address:
        :param expiration:
        :param card_cvv:
        :param card_on_file:
        :param merchant_account_id:
        :param verify_name:
        :param holder_name:
        :param retries: Override the default retry configuration for this method
        :param server_url: Override the default server URL for this method
        :param timeout_ms: Override the default request timeout configuration for this method in milliseconds
        :param http_headers: Additional headers to set or replace on requests.
        """
        base_url = None
        url_variables = None
        if timeout_ms is None:
            timeout_ms = self.sdk_configuration.timeout_ms

        if server_url is not None:
            base_url = server_url

        request = operations.UpdateCardRequest(
            x_moov_version=x_moov_version,
            account_id=account_id,
            card_id=card_id,
            update_card=components.UpdateCard(
                e2ee=utils.get_pydantic_model(
                    e2ee, Optional[components.E2EETokenUpdate]
                ),
                billing_address=utils.get_pydantic_model(
                    billing_address, Optional[components.UpdateCardAddress]
                ),
                expiration=utils.get_pydantic_model(
                    expiration, Optional[components.UpdateCardExpiration]
                ),
                card_cvv=card_cvv,
                card_on_file=card_on_file,
                merchant_account_id=merchant_account_id,
                verify_name=verify_name,
                holder_name=holder_name,
            ),
        )

        req = self._build_request_async(
            method="PATCH",
            path="/accounts/{accountID}/cards/{cardID}",
            base_url=base_url,
            url_variables=url_variables,
            request=request,
            request_body_required=True,
            request_has_path_params=True,
            request_has_query_params=True,
            user_agent_header="user-agent",
            accept_header_value="application/json",
            http_headers=http_headers,
            security=utils.get_pydantic_model(security, operations.UpdateCardSecurity),
            get_serialized_body=lambda: utils.serialize_request_body(
                request.update_card, False, False, "json", components.UpdateCard
            ),
            timeout_ms=timeout_ms,
        )

        if retries == UNSET:
            if self.sdk_configuration.retry_config is not UNSET:
                retries = self.sdk_configuration.retry_config

        retry_config = None
        if isinstance(retries, utils.RetryConfig):
            retry_config = (retries, ["429", "500", "502", "503", "504"])

        http_res = await self.do_request_async(
            hook_ctx=HookContext(
                operation_id="updateCard",
                oauth2_scopes=[],
                security_source=get_security_from_env(security, components.Security),
            ),
            request=req,
            error_status_codes=[
                "400",
                "401",
                "403",
                "404",
                "409",
                "422",
                "429",
                "4XX",
                "500",
                "504",
                "5XX",
            ],
            retry_config=retry_config,
        )

        data: Any = None
        if utils.match_response(http_res, "200", "application/json"):
            return utils.unmarshal_json(http_res.text, components.Card)
        if utils.match_response(http_res, ["400", "409"], "application/json"):
            data = utils.unmarshal_json(http_res.text, errors.GenericErrorData)
            raise errors.GenericError(data=data)
        if utils.match_response(http_res, ["401", "403", "404", "429", "4XX"], "*"):
            http_res_text = await utils.stream_to_text_async(http_res)
            raise errors.APIError(
                "API error occurred", http_res.status_code, http_res_text, http_res
            )
        if utils.match_response(http_res, "422", "application/json"):
            data = utils.unmarshal_json(http_res.text, errors.UpdateCardErrorData)
            raise errors.UpdateCardError(data=data)
        if utils.match_response(http_res, ["500", "504", "5XX"], "*"):
            http_res_text = await utils.stream_to_text_async(http_res)
            raise errors.APIError(
                "API error occurred", http_res.status_code, http_res_text, http_res
            )

        content_type = http_res.headers.get("Content-Type")
        http_res_text = await utils.stream_to_text_async(http_res)
        raise errors.APIError(
            f"Unexpected response received (code: {http_res.status_code}, type: {content_type})",
            http_res.status_code,
            http_res_text,
            http_res,
        )

    def disable_card(
        self,
        *,
        security: Union[
            operations.DisableCardSecurity, operations.DisableCardSecurityTypedDict
        ],
        account_id: str,
        card_id: str,
        x_moov_version: Optional[components.Versions] = None,
        retries: OptionalNullable[utils.RetryConfig] = UNSET,
        server_url: Optional[str] = None,
        timeout_ms: Optional[int] = None,
        http_headers: Optional[Mapping[str, str]] = None,
    ):
        r"""Disables a card associated with a Moov account.

        To use this endpoint from the browser, you'll need to specify the `/accounts/{accountID}/cards.write` scope when generating
        a [token](https://docs.moov.io/api/authentication/access-tokens/).

        :param security:
        :param account_id:
        :param card_id:
        :param x_moov_version: Specify an API version.
        :param retries: Override the default retry configuration for this method
        :param server_url: Override the default server URL for this method
        :param timeout_ms: Override the default request timeout configuration for this method in milliseconds
        :param http_headers: Additional headers to set or replace on requests.
        """
        base_url = None
        url_variables = None
        if timeout_ms is None:
            timeout_ms = self.sdk_configuration.timeout_ms

        if server_url is not None:
            base_url = server_url

        request = operations.DisableCardRequest(
            x_moov_version=x_moov_version,
            account_id=account_id,
            card_id=card_id,
        )

        req = self._build_request(
            method="DELETE",
            path="/accounts/{accountID}/cards/{cardID}",
            base_url=base_url,
            url_variables=url_variables,
            request=request,
            request_body_required=False,
            request_has_path_params=True,
            request_has_query_params=True,
            user_agent_header="user-agent",
            accept_header_value="application/json",
            http_headers=http_headers,
            security=utils.get_pydantic_model(security, operations.DisableCardSecurity),
            timeout_ms=timeout_ms,
        )

        if retries == UNSET:
            if self.sdk_configuration.retry_config is not UNSET:
                retries = self.sdk_configuration.retry_config

        retry_config = None
        if isinstance(retries, utils.RetryConfig):
            retry_config = (retries, ["429", "500", "502", "503", "504"])

        http_res = self.do_request(
            hook_ctx=HookContext(
                operation_id="disableCard",
                oauth2_scopes=[],
                security_source=get_security_from_env(security, components.Security),
            ),
            request=req,
            error_status_codes=[
                "400",
                "401",
                "403",
                "404",
                "409",
                "429",
                "4XX",
                "500",
                "504",
                "5XX",
            ],
            retry_config=retry_config,
        )

        data: Any = None
        if utils.match_response(http_res, "204", "*"):
            return
        if utils.match_response(http_res, ["400", "409"], "application/json"):
            data = utils.unmarshal_json(http_res.text, errors.GenericErrorData)
            raise errors.GenericError(data=data)
        if utils.match_response(http_res, ["401", "403", "404", "429", "4XX"], "*"):
            http_res_text = utils.stream_to_text(http_res)
            raise errors.APIError(
                "API error occurred", http_res.status_code, http_res_text, http_res
            )
        if utils.match_response(http_res, ["500", "504", "5XX"], "*"):
            http_res_text = utils.stream_to_text(http_res)
            raise errors.APIError(
                "API error occurred", http_res.status_code, http_res_text, http_res
            )

        content_type = http_res.headers.get("Content-Type")
        http_res_text = utils.stream_to_text(http_res)
        raise errors.APIError(
            f"Unexpected response received (code: {http_res.status_code}, type: {content_type})",
            http_res.status_code,
            http_res_text,
            http_res,
        )

    async def disable_card_async(
        self,
        *,
        security: Union[
            operations.DisableCardSecurity, operations.DisableCardSecurityTypedDict
        ],
        account_id: str,
        card_id: str,
        x_moov_version: Optional[components.Versions] = None,
        retries: OptionalNullable[utils.RetryConfig] = UNSET,
        server_url: Optional[str] = None,
        timeout_ms: Optional[int] = None,
        http_headers: Optional[Mapping[str, str]] = None,
    ):
        r"""Disables a card associated with a Moov account.

        To use this endpoint from the browser, you'll need to specify the `/accounts/{accountID}/cards.write` scope when generating
        a [token](https://docs.moov.io/api/authentication/access-tokens/).

        :param security:
        :param account_id:
        :param card_id:
        :param x_moov_version: Specify an API version.
        :param retries: Override the default retry configuration for this method
        :param server_url: Override the default server URL for this method
        :param timeout_ms: Override the default request timeout configuration for this method in milliseconds
        :param http_headers: Additional headers to set or replace on requests.
        """
        base_url = None
        url_variables = None
        if timeout_ms is None:
            timeout_ms = self.sdk_configuration.timeout_ms

        if server_url is not None:
            base_url = server_url

        request = operations.DisableCardRequest(
            x_moov_version=x_moov_version,
            account_id=account_id,
            card_id=card_id,
        )

        req = self._build_request_async(
            method="DELETE",
            path="/accounts/{accountID}/cards/{cardID}",
            base_url=base_url,
            url_variables=url_variables,
            request=request,
            request_body_required=False,
            request_has_path_params=True,
            request_has_query_params=True,
            user_agent_header="user-agent",
            accept_header_value="application/json",
            http_headers=http_headers,
            security=utils.get_pydantic_model(security, operations.DisableCardSecurity),
            timeout_ms=timeout_ms,
        )

        if retries == UNSET:
            if self.sdk_configuration.retry_config is not UNSET:
                retries = self.sdk_configuration.retry_config

        retry_config = None
        if isinstance(retries, utils.RetryConfig):
            retry_config = (retries, ["429", "500", "502", "503", "504"])

        http_res = await self.do_request_async(
            hook_ctx=HookContext(
                operation_id="disableCard",
                oauth2_scopes=[],
                security_source=get_security_from_env(security, components.Security),
            ),
            request=req,
            error_status_codes=[
                "400",
                "401",
                "403",
                "404",
                "409",
                "429",
                "4XX",
                "500",
                "504",
                "5XX",
            ],
            retry_config=retry_config,
        )

        data: Any = None
        if utils.match_response(http_res, "204", "*"):
            return
        if utils.match_response(http_res, ["400", "409"], "application/json"):
            data = utils.unmarshal_json(http_res.text, errors.GenericErrorData)
            raise errors.GenericError(data=data)
        if utils.match_response(http_res, ["401", "403", "404", "429", "4XX"], "*"):
            http_res_text = await utils.stream_to_text_async(http_res)
            raise errors.APIError(
                "API error occurred", http_res.status_code, http_res_text, http_res
            )
        if utils.match_response(http_res, ["500", "504", "5XX"], "*"):
            http_res_text = await utils.stream_to_text_async(http_res)
            raise errors.APIError(
                "API error occurred", http_res.status_code, http_res_text, http_res
            )

        content_type = http_res.headers.get("Content-Type")
        http_res_text = await utils.stream_to_text_async(http_res)
        raise errors.APIError(
            f"Unexpected response received (code: {http_res.status_code}, type: {content_type})",
            http_res.status_code,
            http_res_text,
            http_res,
        )
